
\documentclass[DynamicalBook]{subfiles}
\begin{document}
%


\setcounter{chapter}{1}%Just finished 1.


\chapter{Non-deterministic doctrines}\label{sec.non_deterministic_systems}

So far, we have seen how deterministic systems of the discrete- and
continuous-time variety can be wired together. But modelling a system
deterministically can be a bit hubristic: it assumes we have taken account of
all variables that act on the state of the system, so that we can know exactly
what will happen next or exactly how the system is tending to change. Often we
know that the way we've modeled state is incomplete, and so knowing the state in
our model might not tell us exactly what will happen next.

As an example, consider a person typing out an email. We know that the output of
this system over time will be a stream of ASCII characters, and we won't model the various sorts
of inputs that might be affecting the person as they write the email. The
particular email written will depend on the person's state, but this state is
extraordinarily complex and modelling it to the point that we would know exactly
which email they will write is nigh impossible. 

So, instead, we could use what
we know about how emails that this person writes tend to look to predict what
the next character will be. This would give us a \emph{stochastic} model of the
email-writer system.

In this section, we will see a variety of non-deterministic (discrete-time)
doctrines. The kind of non-deterministism --- possibilistic, stochastic, etc.
--- will be encoded in a \emph{commutative monad}
(\cref{def.commutative_monad}). 

\section{Possibilistic  systems}

Suppose that we are observing a deterministic system $\Sys{S}$ from the outside.
We can choose what input $i \in \In{S}$ to put into the system, and we observe
from that what output $o \in \Out{S}$ comes out as a result. Can we understand
how the system works from knowing this alone? In other words, can we construct a
new system $\Sys{S'}$ just from knowing how inputs relate to outputs in $\Sys{S}$?

In full generality, the answer is of course ``no''; if there was only one
possible output, for example, we have no chance to understand what's going on
inside the system. But if we do observe a bunch of different changing outputs,
we can give it a shot.

As a first guess, we might try to model how an input $i \in \In{S}$ changes the
output $o \in \Out{S}$ that we are seeing. That is, we might try and make
$\State{S'} = \Out{S}$, and then define the new dynamics $\update{S'}(o, i)$ be
the new output $\Sys{S}$ gives when fed input $i$ while it is exposing output
$o$. There's just one problem with this idea: we won't always get the same
output when we feed $i$ in to $\Sys{S}$ while it's exposing $o$.

For example, consider the following transition system:
\begin{equation}\label{eqn.possibilistic_transition_1}
\Sys{S} \coloneqq
  \begin{tikzpicture}[baseline=(bl)]
	\node[draw] (bl) {
  \begin{tikzcd}[column sep=small]
    \LMOO{1}{\Blue} \ar[loop left, "\const{false}"] \ar[rr, bend left, "\const{true}"] \ar[dd, leftarrow, bend right, "\true"'] &  & \LMOO{2}{\Red} \ar[loop right, "\true"] \ar[dd, bend left, "\const{false}" ]\\
    & & \\
    \LMOO{3}{\Blue} \ar[loop left, "\false"] \ar[rr, leftarrow, bend left, "\false"] \ar[rr, leftarrow, bend right, "\true"'] & & \LMOO{4}{\Green}
  \end{tikzcd}};
\end{tikzpicture}
\end{equation}
The inputs to this system are from the set $\In{S} = \{\true, \false\}$, and
the outputs are from the set $\Out{S} = \{\Red, \Blue, \Green\}$. Suppose that we can only see
what the system is outputing, and that it is outputing $\Blue$. If we feed the
system $\false$, we will see $\Blue$. But, if we feed the system $\true$, what
happens depends on whether the system was in state $1$ or state $3$; if we were
in state $1$, then we will see $\Red$, but if were were in state $3$, we will
see $\Blue$. So, the next output is not uniquely determined by the current
output and current input --- there are many possibilities. We are tempted to say
that $\Blue$ will transition to \emph{either} $\Red$ or $\Blue$ in our model
$\Sys{S'}$ of the system $\Sys{S}$. That is, we want the update of $\Sys{S'}$ to
tell us what is \emph{possible}, since we can't know just from the outputs of
$\Sys{S}$ what is \emph{determined} to happen. We can do that by having the
update of $\Sys{S'}$ give us the set of possibilities:
$$\update{S'}(\Blue, \true) = \{\Blue, \Red\}.$$


In this section, we will see two dynamical system doctrines which, instead of
telling us the next state, tell us which states are possible or which are
probable. Both are examples of \emph{non-deterministic} doctrines, since the
current state doesn't determine precisely the next state.

\begin{definition}\label{def.possibilistic_system}
  A \emph{possibilistic system} $\Sys{S}$, also written as 
  $$\lens{\update{S}}{\expose{S}} : \lens{\State{S}}{\State{S}} \leftrightarrows \lens{\In{S}}{\Out{S}},$$ 
  consists of:
  \begin{itemize}
    \item a set $\State{S}$ of \emph{states};
    \item a set $\Out{S}$ of \emph{values for exposed variables}, or \emph{outputs}
      for short;
    \item a set $\In{S}$ of \emph{parameter values}, or \emph{inputs} for short;
    \item a function $\expose{S} : \State{S} \to \Out{S}$, the \emph{exposed variable of state} or
      \emph{expose} function, which takes a state to the output it yields; and
    \item a function $\update{S} : \State{S} \times \In{S} \to
      \powset\State{S}$, where $\powset\State{S}$ is the set of subsets of
      $\State{S}$. This is the \emph{dynamics} or
      \emph{update} function which takes a state and a parameter and gives the
      set of possible next states.
  \end{itemize}
\end{definition}

\begin{remark}
  While \cref{def.deterministic_system} can be interepreted in any cartesian
  category because it only used maps and the cartesian product,
  \cref{def.possibilistic_system} makes use of the \emph{power set} operation
  $\powset$ which sends a set to its set of subsets. This can't be interpreted
  in any cartesian category --- we need something resembling $\powset$ in order
  for it to make sense.
\end{remark}

\begin{example}\label{ex.transition_possible}
  A possibilistic automaton can be presented as a transition diagram as well.
  Consider, for example, the following diagram:

\begin{equation}\label{eqn.transition_possible}  
\Sys{S'} \coloneqq
  \begin{tikzpicture}[baseline=(bl)]
	\node[draw] (bl) {
  \begin{tikzcd}[column sep=small]
    \LMO{\Blue} \ar[out=60, in=120, looseness=2, "\true"'] \ar[loop left, "\const{false}"] \ar[rr, bend left, "\const{true}"]  &  & \LMO{\Red} \ar[loop right, "\true"] \ar[dd, bend left, "\const{false}" ]\\
    & & \\
     & & \ar[uull, bend right, "\true"]\ar[uull, bend left, "\false"'] \LMO{\Green}
  \end{tikzcd}};
\end{tikzpicture}
\end{equation}

This system resembles system $\Sys{S}$ of \cref{eqn.possibilistic_transition_1},
except that it has a single state for each output. We can tell that this
transition diagram represents a possibilistic system because there are two
arrows leaving $\Blue$ both labeled $\true$. Since the dynamics of a transition
diagram are given by following the arrow labeled by the input along to a new
state, we see that here we will end up at a set of states:
$$\update{S'}(\Blue, \true) = \{\Blue, \Red\}.$$
\end{example}

\begin{example}\label{ex.nfa}
 In \cref{ex.dfa}, we saw that deterministic finite automata (DFAs) are examples of
 deterministic systems. There is another common notion in automata theory:
 \emph{non-deterministic} finite automata (NFAs). 

 An NFA is a possibilistic system $\Sys{S}$ with finitely many states whose
 output values are Booleans: $\Out{S} = \{\true, \false\}$. As with DFAs, the exposed variable $\expose{S} : \State{S}
 \to \{\true, \false\}$ tells us whether or not a state is an accept state.

 Again, NFAs are question answering machines. But this time, since they are
 non-deterministic, we ask whether or not it is \emph{possible} to accept a
 given sequence of inputs. Suppose we have a sequence of inputs $i_0, \ldots,
 i_n$, and we start in a state $s_0$. Now, because an NFA is possibilistic, we
 don't have a ``next state'' $s_1$. Rather, we have a set of states $S_1
 \coloneqq \update{S}(s_0, i_0)$. Now, we need to interatively define the next
 evolution: $S_2$ should be the set of states that are possible to get to from
 \emph{any} state in $S_1$. Generally,
 $$S_{j+1} \coloneqq \{s'  \mid s \in S_j, s' \in \update{S}(s, i_j) \} = \bigcup_{s \in
   S_j} \update{S}(s, i_j)$$
 We then say that the machine accepts the input sequence if there is any accept
 state in $S_n$.
\end{example}

\cref{ex.nfa} contains an answer to an interesting question: how do we iterate
the behavior of a possibilistic system? For a deterministic system whose update
has the signature $\update{S} : \State{S} \times \In{S} \to \State{S}$, we can
compose to get
$$\State{S} \times \In{S} \times \In{S} \xto{\update{S} \times \In{S}} \State{S}
\times \In{S} \xto{\update{S}} \State{S}$$
which sends $(s, (i_0, i_1))$ to $\update{S}(\update{S}(s, i_0), i_1)$. We can
do this as many times as we like to apply an entire sequence of inputs to a
state.

But for a possibilistic system, the update has signature $\update{S} :
\State{S} \times \In{S} \to \powset \State{S}$. Now we can't just compose, if we
tried the trick above we would go from $\State{S} \times \In{S} \times \In{S}
\to \powset\State{S} \times \In{S}$, and we're stuck.

But from $\update{S} : \State{S} \times \In{S} \to \powset\State{S}$ we can
define a function $U : \powset \State{S} \times \In{S} \to
\powset\State{S}$ by
\[
U(S, i) = \{s' \mid s \in S,\, s' \in \update{S}(s, i)\} =
\bigcup_{s \in S} \update{S}(s, i)
\]
Then we can define the iterated action of the system to be the composite
$$\State{S} \times \In{S} \times \In{S} \xto{\update{S}} \powset \State{S}
\In{S} \xto{U} \powset \State{S}.$$

This process of lifting a function $A \times B \to \powset C$ to a function
$\powset A \times B \to \powset C$ is fundamental, and worthy of abstraction.
This operation comes from the fact that $\powset$ is a \emph{commutative monad}.
\begin{definition}\label{def.commutative_monad}
Let $\cat{C}$ be a cartesian category. A \emph{monad} $(M, \eta)$ on $\cat{C}$ consists of:
\begin{itemize}
  \item An assignment of an object $MA$ to every object $A \in \cat{C}$.
  \item For every object $A \in \cat{A}$, a map $\eta_A : A \to MA$.
  \item For every map $f : A \to MB$, a \emph{lift} $f^M : MA \to MA$. 
\end{itemize}
This data is required to satisfy the following laws:
\begin{itemize}
  \item (Unit) For any object $A$, \[\eta_{A}^M = \id_{MA}.\]
  \item (Identity) For any map $f : A \to MB$, \[f^M \circ \eta_A = f.\]
  \item (Composition) For any $f : A \to MB$ and $g : B \to MC$,
\[ g^M \circ f^M = (g^M \circ f)^M.\]
\end{itemize}
From this data, we note that we can extend $M$ into a functor $M : \cat{C} \to
\cat{C}$ by sending $f : A \to B$ to $Mf \coloneqq (\eta_B \circ f)^M : MA \to
MB$.
Then $\eta : A \to MA$ is natural in $A$, and we get another natural
transformation $\mu : MM A \to M A$ defined by lifting the identity: $\mu
\coloneqq \id^M$. In fact, a monad may be equivalently defined as a functor $M :
\cat{C} \to \cat{C}$ with natural transformations $\eta : A \to MA$ and $\mu :
M^2 A \to MA$ for which the following diagrams commutes:
\begin{equation}\label{eqn.monad_laws}
\begin{tikzcd}
MA \arrow[r, "\eta"] \arrow[rd, equals] & M^2A \arrow[d, "\mu"] & MA \arrow[l, "M\eta"'] \arrow[ld, equals] &  & M^3A \arrow[r, "\mu"] \arrow[d, "M\mu"'] & M^2 A \arrow[d, "\mu"] \\
                                & MA                                &                                   &  & M^2 A \arrow[r, "\mu"']                  & MA                    
\end{tikzcd}
\end{equation}
For $f : A \to M B$, we can recover $f^M : M A \to MB$ from this definition of
the monad $M$ as
$M A \xto{M f} M^2 B \xto{\mu} M B$.

A monad $M$ is said to be \emph{commutative} if there is a natural
transformation $\sigma : MA \times MB \to M(A \times B)$ for which the following diagrams commute:
\begin{itemize}
\item 
  \begin{equation}\label{eqn.com_monad_right_unit}
    \begin{tikzcd}
      MA \times \ord{1} \ar[dr, "\pi_1"'] \ar[r, "(MA \times \eta) \then \sigma_{A, \ord{1}}"]& M(A
      \times \ord{1}) \ar[d, "M\pi_1"] \\
      & MA
    \end{tikzcd}
    \end{equation}
\item 
  \begin{equation}\label{eqn.com_monad_left_unit}
    \begin{tikzcd}
      \ord{1} \times MA \ar[dr, "\pi_2"'] \ar[r, "(\eta \times MA) \then \sigma_{\ord{1}, A}"]& M(\ord{1}
      \times A) \ar[d, "M\pi_2"] \\
      & MA
    \end{tikzcd}
    \end{equation}
\item 
\begin{equation}\label{eqn.com_monad_assoc} 
    \begin{tikzcd}
      MA \times MB \times MC \ar[r, "MA \times \sigma_{B, C}"] \ar[d,"\sigma_{A,
      B} \times MC"'] & MA \times M(B \times C) \ar[d, "\sigma_{A, B \times C}"]
    \\
    M(A \times B) \times MC \ar[r, "\sigma_{A \times B, C}"'] & M(A \times B
    \times C)
    \end{tikzcd}
    \end{equation}
  \item 
\begin{equation}\label{eqn.com_monad_monad_unit} 
    \begin{tikzcd}
      A \times B \ar[r, "{\eta \times \eta}"] \ar[dr, "{\eta}"'] & M A \times M B \ar[d, "{\sigma}"] \\
      & M(A \times B)
    \end{tikzcd}
    \end{equation}
  \item 
\begin{equation}\label{eqn.com_monad_monad_mult} 
    \begin{tikzcd}
      M^2 A \times M^2 B \ar[r, "{\sigma\then M\sigma}"] \ar[d, "{\mu \times \mu}"'] & M^2(A \times B) \ar[d, "\mu"] \\
      M A \times M B \ar[r, "{\sigma}"'] & M(A \times B)
    \end{tikzcd}
    \end{equation}
\end{itemize}
\end{definition}

\begin{remark}\label{rmk.haskell_do}
  If you are familiar with the programming language Haskell, you will likely be
  familiar with the notion of monad. What we have called $\eta_A$ here (which is
  traditional in the category theory literature) is called
  \mintinline{haskell}{return} or \mintinline{haskell}{pure}. What we have
  called $f^M$ for $f : A \to MB$ would, in haskell, be called
  \mintinline{haskell}{lift} and be defined by

  \mint{haskell}|lift = swap (>>=)|

  What we have called $\mu$ is called \mintinline{haskell}{join}. A monad in haskell is commutative if the following two programs have the same
  results:
  \begin{minted}{haskell}
    f :: Monad m => m a -> m b -> m (a, b)
    f ma ma = do
               a <- ma
               b <- mb
               return (a, b)

    g :: Monad m => m a -> m b -> m (a, b)
    g ma ma = do
               b <- mb
               a <- ma
               return (a, b)
  \end{minted}
  That is, a monad is commutative when its order of execution doesn't matter. 
\end{remark}

\begin{proposition}\label{prop.powerset_commutative_monad}
  The powerset $\powset$ is a commutative monad on the category of sets, with
  the following data:
  \begin{itemize}
   \item $\eta : A \to \powset A$ sends $a \in A$ to the singleton set $\{a\}$.
   \item For $f : A \to \powset B$, $f^{\powset} : \powset A \to \powset B$ is
     defined by
     $$f^{\powset}(X) = \bigcup_{a \in X} f(a).$$
   \item $\sigma_{A, B} : \powset A \times \powset B \to \powset (A \times B)$
     is defind by
     $$\sigma_{A, B}(X, Y) = \{(a, b) \mid a \in X, b \in Y\}.$$
  \end{itemize}
\end{proposition}
\begin{proof}
  We just need to check the laws.
  \begin{itemize}
    \item The function $\eta_A^{\powset}$ takes a set $X \in \powset A$ and
      yields $\bigcup_{x \in X} \{x\}$, which is equal to $X$.
    \item Let $f : A \to \powset B$ be a function. Then $f^{\powset}(\{a\}) =
      \bigcup_{a' \in \{a\}}f(a') = f(a)$ for any element $a \in A$.
    \item Let $f : A \to \powset B$ and $g : B \to \powset C$. For $X \in
      \powset A$, we have
\begin{align*}
  g^{\powset} \circ f^{\powset}(X) &= \bigcup_{b \in f^{\powset}(X)} g(b) \\
&= \bigcup_{b \in \bigcup_{a \in X} f(a)} g(b) \\
&= \bigcup_{a \in X} \bigcup_{b \in f(a)} g(b) \\
&= (g^{\powset} \circ f)^{\powset}.
\end{align*}
  \end{itemize}
  
It remains to show that the powerset monad is commutative. We note that
$\powset$ acts as a functor on $f : A \to B$ by 
\[
\powset f (X) = (\eta_B \circ
f)^{\powset}(X) = \bigcup_{a \in X}\{f(a)\} = f[X].
\]
sending a subset of $A$ to its image in $B$. We also note that $\mu : \powset^2
A \to \powset A$ defined by $\mu = \id_{\powset A}^{\powset}$ sends a set $S$
of subsets of $S$ to its union $\bigcup{s \in S} s$.
\begin{itemize}
  \item (\cref{eqn.com_monad_right_unit}) Beginning with $(X, \ast) \in \powset
    A \times \ord{1}$ (taking $\ord{1} \cong \{\ast\}$), we need to
    show that $\powset \pi_1 \circ \sigma_{A, \ord{1}}(X, \{\ast\}) = X$. Now,
    $\sigma_{A, \ord{1}}(X, \{\ast\}) = \{(a, b) \mid a \in X, b \in \{\ast\}\}$; since
    there is just one $b \in \{\ast\}$, every $a \in X$ is paired with
    some $b$, so projecting out the first component gives us all of $X$.
    \item (\cref{eqn.com_monad_left_unit}) This is the same as the above, but on the other side.
    \item (\cref{eqn.com_monad_assoc}) If we have $(X, Y, Z) \in \powset A \times \powset B \times \powset
      C$, both sides of this diagram will give us $\{(a, b, c) \mid a \in X, b
      \in Y, c \in Z\}$. 
    \item (\cref{eqn.com_monad_monad_unit}) For $(a, b) \in A \times B$, we have
      $\eta(a, b) = \{a, b\}$, and $\sigma(\eta(a), \eta(b)) = \{(x, y) \mid x
      \in \{a\},\, y \in \{b\}\}$.
   \item (\cref{eqn.com_monad_monad_mult}) Let $S$ be a set of subsets of $A$
     and $T$ a set of subsets of $B$. The bottom path gives us
     \[
\sigma(\mu(S), \mu(T)) = \left\{(x, y) \,\middle|\, x \in \bigcup_{s \in S} s,\, y \in \bigcup_{t \in T} t\right\}
\]
while taking the top path, we first get $\sigma(S, T) = \{(s, t) \mid s \in S,\,
t \in T\}$ and then $M\sigma$ of that to get
\[
\sigma\left[ \{(s, t) \mid s \in S,\, t \in T\} \right] = \{\{(x, y) \mid x \in
s,\, y \in t\} \mid s \in S,\, t \in T\}.
\]
Finally, we take the union over this to get
\[
\mu(\powset \sigma(\sigma(S, T))) = \bigcup_{s \in S,\, t \in T}\{(x, y) \mid x \in s,\, y \in t\}.
\]
These two paths are easily seen to give the same result.
\end{itemize}
\end{proof}

Using the commutative monad structure of $\powset$, we can see that $U : \powset
\State{S} \times \In{S} \to \powset \State{S}$ is the composite
$$\powset \State{S} \times \In{S} \xto{\id \times \eta}
\powset\State{S} \times \powset\In{S} \xto{\sigma} \powset(\State{S} \times
\In{S}) \xto{\update{S}^{\powset}} \powset\State{S}.$$
This lets us iteratively apply the update function to a starting state or set of
states.

It also lets us get the exposed variable out at the end. If we've been
iteratively running a possibilistic system $\Sys{}$, then we won't know which state we
are in but instead have a set $S \in \powset \State{S}$ of states we could
possibly be in. Because of this, we can't directly apply $\expose{S} : \State{S}
\to \Out{S}$, since it takes in a single state. But the monad structure of
$\powset$ gives us a function $\powset \expose{S} : \powset\State{S} \to
\powset\Out{S}$. Applying this to our current set of possible states gives us a
set of possible outputs, which is the best we could hope to know.

\paragraph{Do Notation}\label{sec.do_notation}

If we have a function $f : X \to Y$, we can think of this as mapping $x$ in $X$
to $f(x)$ in $Y$ using ``generalized elements'' (see
\cref{rmk.generalized_elements}). The \emph{do notation} extends this way of
writing morphisms in a cartesian category to include the action of a commutative
monad $M$. The do notation is based on this simple
equation for $f : X \to MY$:
\begin{equation}\label{eqn.do_notation_def}
\unalignedDo{
  $x \from m$,
  $f(x)$
}
\coloneqq f^M(m)
\end{equation}
where $m$ is an element of $MX$ and $f : X \to MY$. For $M = \probset$, we can
understand the do notation in this way: $m$ is a subset of $X$, $f^M(m)$ is the
subset $\{f(x) \in Y \mid x \in m\}$. We see this reflected in the do notation;
we can read it as saying ``get an element $x$ from $m$, and then apply $f(x)$ to
it; join together all the results.'' As we see more monads, we will see that a
similar story can be told about them using the do notation.


There are a few rules for do notation which correspond to the laws for a
monad. We can discover them by using \cref{eqn.do_notation_def} to expand out a
few terms. First of all, since $\eta^M = \id_{MX}$, if $m$ is an element of $MX$, then
\[
  \unalignedDo{
    $x \from m$,
    $\eta(x)$
  } = m
\]
Next, since $\eta \then f^M = f$, we find that
\[
  \unalignedDo{
    $x' \from \eta(x)$,
    $f(x')$
  }
  = f(x) 
\]
Finally, since $f^M \then g^M = (f \then g^M)^M$, we find that
\[
\unalignedDo{
  \(y \from \unalignedDo{
    $x \from m$,
    $f(x)$
  }\),
  $g(y)$
} = 
\unalignedDo{
  $x \from m$,
  {
    \unalignedDo{
       $y \from f(x)$,
       $g(y)$
    }
  }
}
\]
Because these
two expressions with nested do's are equal, we can simplify
our notation by writing them as:
\[
\unalignedDo{
  $x \from m$,
  $y \from f(x)$,
  $g(y)$
}
\]

So far, we haven't used any pairs $(x, y)$ in our do notation. To use pairs, we
need our monad to be commutative. We can write down two expressions, assuming $m_1$ is an element of $MX$ and $m_2$ is an element of $MY$. A monad is
commutative precisely when these two expressions are equal:
\[
  \unalignedDo{
    $x \from m_1$,
    $y \from m_2$,
    $\eta{(x, y)}$
  }
  =
  \unalignedDo{
    $y \from m_2$,
    $x \from m_1$,
    $\eta{(x, y)}$
  }
\]
When they are both equal, they are $\sigma(m_1, m_2)$, where $\sigma : MX \times MY \to M(X \times
Y)$ is from the definition of a commutative monad. This lets us describe morphisms
quite nicely. For example, given $f : X \to MY$, $g : Z \to MW$, and $h : Y
\times W \to MQ$, we may define
\[
  \unalignedDo{
    $y \from f(x)$,
    $w \from g(z)$,
    $h{(y, w)}$
  }
\]
which desugars to the composite
\[
X \times Z \xto{f \times g} MY \times MW \xto{\sigma} M(Y \times W) \xto{h^M}
MQ.
\]

In particular, to iterate a system $\Sys{S}$ with update $\update{S} : \State{S}
\times \In{S} \to \probset \State{S}$, we can define
\[
U(S, i) \coloneqq \unalignedDo{
  $s \from S$,
  $\update{S}{(s, i)}$
}
\]

\section{Stochastic systems}
Possibility is not the only kind of non-determinism. When studying how things
change in the world, we often notice that we can only predict how likely some
change will be, and not precisely which change will occur. If instead of asking
whether a change is possible, we ask how \emph{probable} it is, we arrive at a
notion of probabilistic or \emph{stochastic} system.

The notion of a stochastic system is based on the idea that there should be a
probability of a given change occuring, conditioned upon the current state. A
useful way to formulate the notion of conditional probability is the notion of
\emph{stochastic map}. A stochastic map from $A$ to $B$ is a function
which takes an $a \in A$ and yields a probability distribution $p(- \mid a)$ on
elements of $B$ which we think of as likelyhoods conditioned on $a$. We can make
this more precise using the notion of monad.

\begin{definition}\label{def.set_of_probs}
  For a set $A$, the set $\probset A$ is the set of finitely supported
  probability distributions on $A$. A probability distribution on $A$ is a
  function $p : A \to [0, 1]$ which takes non-zero values at only finitely many
  elements of $A$, and for which
  $$\sum_{a \in A} p(a) = 1.$$
This sum makes sense because only finitely many elements of $A$ give non-zero $p(a)$.
  
  The elements of $\probset A$ can be identified with  
  \emph{formal convex combinations} of elements of $A$. A formal convex
  combination
$$\sum_{a \in X} \lambda_a a$$
  of elements of $A$ consists of a finite and inhabited\footnote{That is, there
    is some $a \in X$.} subset $X \subseteq A$ of
  elements together with a function $\lambda_{(-)} : X \to (0,1]$ assigning each
  $a \in X$ a coefficient $\lambda_a$ such that $\sum_{a \in X} \lambda_a = 1$.
  \[
\probset A = \left\{ \sum_{a \in X} \lambda_a a \,\middle|\, X \subseteq A,\,\mbox{$X$
  finite and inhabited},\, \lambda_{(-)} : X \to (0, 1],\, \sum_{a \in X} \lambda_a = 1\right\}.
  \]
\end{definition}

\begin{example}
  Let's see what $\probset A$ looks like for a few different sets $A$:
  \begin{enumerate}
    \item If $A = \{a\}$ has a single element, then there is only one inhabited
      subset $X \subseteq A$ (namely $X = A$) and since the coefficients of any
      convex linear combination must sum to 1, the coefficient of the single
      element must be $1$. So $\probset \{a\} = \{1 \cdot a\}$ contains a single element.
    \item If $A = \{a, b\}$, things get more interesting. Now there are three
      possible subsets $X$: $\{a\}$, $\{b\}$, and $\{a, b\}$. A convex
      combination with a single element must have coefficient $1$, so we at
      least have the convex combinations $1 \cdot a$ and $1 \cdot b$. But for
      the set $\{a, b\}$, we have the convex combination
      $\lambda_a a + \lambda_b b$ where $\lambda_a + \lambda_b = 1$ and
      $\lambda_a,\, \lambda_b > 0$. If we make the association of $1 \cdot a$
      with $1\cdot a + 0 \cdot b$, and similarly for $1 \cdot b$, then we can
      see that
      \[
\probset \{a, b\} = \{\lambda a + (1 - \lambda) b \mid \lambda \in [0, 1]\}
      \]
      which is bijective with the closed interval $[0, 1]$.
    \item In general, if $A$ is a finite set with $n$ elements, then $\probset
      A$ can be identified with the \emph{standard $n$-simplex}, that is, the
      set of solutions to the equation
      $\sum_{i = 1}^n \lambda_i = 1$
      for $\lambda_i \in [0,1]$.
      \[
\probset \ord{n} \cong \{(\lambda_1, \ldots, \lambda_n) \in [0,1]^n \mid \sum_{i
= 1}^n \lambda_i = 1\}.
      \]
  \end{enumerate}
\end{example}

\begin{definition}\label{def.stochastic_map}
 A \emph{stochastic map} from a set $A$ to a set $B$ is a function $f : A
 \to \probset B$, assigning each $a \in A$ to a probability distribution $f(a)$
 on $B$.

 If the sets $A$ and $B$ are finite, then we can write a stochastic map $f
 : A \to \probset B$ as a \emph{stochastic matrix}. This is an $B \times A$
 matrix whose $ba$-entry is $f(a)(b)$. Any matrix of positive entries where
 every column sums to $1$ arises as the stochastic matrix of a stochastic map.
\end{definition}

We think of a stochastic map $f : A \to \probset B$ as giving a bunch of
conditional probabilities
$$p(b \mid a) \coloneqq f(a)(b).$$

\begin{example}\label{ex.stochastic_function}
  If I see someone enter the office soaking wet, it is likely to have been
  raining. If they are dry, it may be less likely that it was raining; but, if
  they have an umbrella, then they might be dry but it is still more likely that
  it was raining. We can express these various conditional probabilities as a
  stochastic function
  \[
\{\const{wet}, \const{dry}\} \times \{\const{umbrella}, \const{no-umbrella}\}
\to \probset \{\const{raining}, \const{not-raining}\}.
  \]
 We can describe this stochastic function in full by giving its stochastic
 matrix:
 \[
   \kbordermatrix{
      & (\const{wet}, \const{umbrella}) & (\const{wet}, \const{no-umbrella}) &
      (\const{dry}, \const{umbrella}) & (\const{dry}, \const{no-umbrella}) \\
      \const{raining} & .9 & .9 & .5 & .3 \\
      \const{not-raining} & .1 & .1 & .5 & .7
  }
 \]
\end{example}

A stochastic system is a system whose dynamics is given by a stochastic map. 
\begin{definition}\label{def.stochastic_system}
  A \emph{stochastic system} $\Sys{S}$, also written as 
  $$\lens{\update{S}}{\expose{S}} : \lens{\State{S}}{\State{S}} \leftrightarrows \lens{\In{S}}{\Out{S}},$$ 
  consists of:
  \begin{itemize}
    \item a set $\State{S}$ of \emph{states};
    \item a set $\Out{S}$ of \emph{values for exposed variables}, or \emph{outputs}
      for short;
    \item a set $\In{S}$ of \emph{parameter values}, or \emph{inputs} for short;
    \item a function $\expose{S} : \State{S} \to \Out{S}$, the \emph{exposed variable of state} or
      \emph{expose} function, which takes a state to the output it yields; and
    \item a function $\update{S} : \State{S} \times \In{S} \to
      \powset\State{S}$, where $\probset\State{S}$ is the set of subsets of
      $\State{S}$. This is the \emph{dynamics} or
      \emph{update} function which takes a state and a parameter and gives the
      set of possible next states.
  \end{itemize}
\end{definition}

\begin{remark}
 A stochastic system is often called a \emph{Markov process}. 
\end{remark}

\begin{example}\label{ex.markov_text_generator}
  A simple, but entertaining example of a stochastic system is a text generator.
  Suppose we have a big pile of text --- say, the speeches of a famous person
  --- and we want to generate some text that looks like it was written by the
  same author. There are many sophisticated ways to do this, but here's a very
  bone-headed approach. We will look at the text in $5$-character length
  sequences, and ask: how likely is for a given character to follow this
  $5$-character sequence.

  For example, if our text is
  \begin{center}
To be or not to be, that is the question.
  \end{center}
Then we can see that there is a $50\%$ chance that `` '' and a $50\%$ chance
that ``,'' follows the $5$-character sequence ``to be''. Of course, such a small
sample woulnd't give us very useful statistics, but if we use the combined works
of Shakespeare, we might get a better sense of what is likely to occur next.

Now we build a stochastic system $\Sys{S}$ which will generate text. We take
$\State{S}$ to be length $5$ sequences of characters from our alphabet
$\Set{Alphabet}$: $\State{S} = \Set{Alphabet}^5$. We will
expose the first character in the sequence: $\Out{S} = \Set{Alphabet}$ and $\expose{S}(s) = s_1$. We don't need any
input to the system: $\In{S} = \{\ast\}$. Now, $\update{S}(s)$ will assign to a
sequence $(s_2, s_3, s_4, s_5, c)$ the probability that the character $c$
follows the sequence $s = (s_1, s_2, s_3, s_4, s_5)$ in our sample text, and
assign all other sequences the probability $0$.

If we run our stochastic text generator over time, it will produce a stream of
characters that have the statistical properties of our sample text. As simple
minded as this approach is, it can produce some fun results:
\begin{quote}
  HAMLET

    Whose image even but now appear'd again!

HORATIO

    From top to toe?

FRANCISCO

    Bernardo, on their promise, as it is a course to any moment leisure, but to persever
    Than the cock, that this believe
    Those friend on Denmark
    Do not dull thy name with a defeated him yesternight.
\end{quote}

%%
%% :CUSTOM-ID:cite-me-shakespeare
%%

\end{example}

\begin{example}
  A \emph{stochastic source process} is a stochastic system $\Sys{S}$ with no
  inputs $\In{S} = \ord{1}$. Such a stochastic system would be boxed up like this:
  \[
\begin{tikzpicture}[oriented WD, every fit/.style={inner xsep=\bbx, inner ysep=\bby}, bbx = 1cm, bby =.5cm, bb min width=1cm, bb port length=4pt, bb port sep=1, baseline=(X.center)]
	\node[bb={0}{1}, fill=blue!10] (X) {$\Sys{Source}$};
	\draw[label] 
		node [right=2pt of X_out1] {}
		;
\end{tikzpicture}
  \]

These are means by which random streams of outputs
  can be generated. In \cref{ex.markov_text_generator}, we described a
  stochastic source process that produced Shakespearean writing (of a stunted
  sort). In his seminal paper ``A mathematical theory of communication'', Claude
  Shannon imagined communicators as stochastic source processes sending somewhat
  random language through various communication channels. This point of view is
  still used today to model communications that have some complicated structure
  which, not knowing how that structure is generated in particular, are best
  modeled as somewhat random processes.
\end{example}

\begin{example}
  We can model a faulty wire as a stochastic system of the following sort:
  \[
\begin{tikzpicture}[oriented WD, every fit/.style={inner xsep=\bbx, inner ysep=\bby}, bbx = 1cm, bby =.5cm, bb min width=1cm, bb port length=4pt, bb port sep=1, baseline=(X.center)]
	\node[bb={1}{1}, fill=blue!10] (X) {$\Sys{FaultyWire}$};
	\draw[label] 
		node [right=2pt of X_out1] {$\Set{Bit}$}
    node [left=2pt of X_in1] {$\Set{Bit}$}
		;
\end{tikzpicture}
  \]
  We will define $\Sys{FaultyWire}$ as follows:
  \begin{itemize}
    \item A faulty wire will either have $\const{good}$ contact,
      $\const{partial}$ contact, or $\const{missing}$ contact, and it will be
      carrying a $\const{high}$ or $\const{low}$ charge:
      \[
\State{FaultyWire} \coloneqq \{\const{high}, \const{low}\} \times \{\const{good}, \const{partial}, \const{missing}\}.
      \]
    \item The faulty wire will take in either a $\const{high}$ or $\const{low}$:
      \[
        \In{FaultyWire} = \Out{FaultyWire} = \Set{Bit} = \{\const{high}, \const{low}\}.
      \]
    \item The faulty wire exposes its current charge:
      \[
\expose{FaultyWire}(b, s) = b.
      \]
     \item The faulty wire will try and set its charge to the charge on the
       incoming wire, but if it is has bad contact, this won't succeed and it
       will have low charge. It's
       contact also has a small chance to decay.
       \begin{align*}
         \update{FaultyWire}((b, \const{good}), i) &= .99(i, \const{good}) + .01(i, \const{partial}), \\
         \update{FaultyWire}((b, \const{partial}), i) &= .50(i, \const{partial}) + .49(\const{low}, \const{partial}) + .01(\const{low}, \const{missing}), \\
         \update{FaultyWire}((b, \const{missing}), i) &= (\const{low}, \const{no}). \\
       \end{align*}
  \end{itemize}

  When wiring up our systems, if we put a faulty wire in between, we will
  introduce the probability of the failure of this wire to communicate into the model.
\end{example}


\begin{example}
We can draw transition diagrams for stochastic systems, just like we do for
deterministic and possibilistic systems. This time, we will label each
transition with the probability that it occurs. We just have to make sure that the probability labels on
all the outgoing transitions with the same input label on any state sum to 1.

For example, here is a stochastic system drawn as a transition diagram:
\begin{equation}\label{eqn.transition_stochastic}  
  \begin{tikzpicture}[baseline=(bl)]
	\node[draw] (bl) {
  \begin{tikzcd}[sep=large]
    \LMO{\Blue} \ar[loop, looseness=2, out=60, in=120, "{\true, .3}"'] \ar[loop, looseness=3, out=240, in=300, "{\false, .6}"'] \ar[r, bend left = 30, "{\false, .4}"] \ar[r, bend right =30, leftarrow, "{\false, .1}"] \ar[r, leftarrow, bend right = 40, "{\true, .9}"']& \LMO{\Red} \ar[loop, looseness=2, out=60, in=120, "{\true, .1}"'] \ar[loop, looseness=3, out=240, in=300, "{\false, .9}"']
  \end{tikzcd}};
\end{tikzpicture}
\end{equation}

\end{example}

The set $\probset$ of probability distributions is a commutative monad, like the
powerset $\powset$ monad.
\begin{proposition}\label{prop.prob_monad}
  The assignment of a set $A$ to its set $\probset A$ of probability
  distributions is a commutative monad with the data:
  \begin{itemize}
    \item $\eta_A : A \to \probset A$ sends every element $a$ to its \emph{Dirac
      delta distribution} $\eta_{A}(a) = 1 \cdot a$ which assigns probability
    $1$ to $a$ and probability $0$ to everything else. As a convex linear
    combination, it looks like this:
    \[
\eta_A(a) = \sum_{a' \in \{a\}} 1 \cdot a'
    \]
    \item Given a stochastic map $f : A \to \probset B$ sending $a \in A$ to $f(a)
      = \sum_{b \in Y_a} \rho_{ba} b$, we can \emph{push
        forward} a probability distribution $p = \sum_{a \in X} \lambda_a a$ on
      $A$ to a probability distribution 
      \[
f^{\probset}(p) \coloneqq \sum_{b \in \bigcup_{a \in X} Y_a} \left(  \sum_{a \in
    X}\rho_{ba} \lambda_a \right) b = \sum_{a \in X} \sum_{b \in Y_a} \rho_{ba}
\lambda_a b
      \]
      on $B$. In classical terms, this says that given conditional probabilities
      $p(b \mid a) \coloneqq f(a)(b)$ and any prior distribution $p(a) \coloneqq
      \lambda_a$, we can
      form a posterior distribution
      $p(b) \coloneqq \sum_{a\in A} p(b \mid a) p(a).$
   \item  Given a probability distribution $\sum_{a \in X} \lambda_a a$ on $A$
     and $\sum_{b \in Y} \mu_b b$ on $B$, we can form their joint distribution
     \[
\sum_{(a, b) \in X \times Y} \lambda_a \mu_b (a, b)
\]
on $A \times B$. This gives us $\sigma : \probset A \times \probset B \to
\probset (A \times B)$. In classical terms, this says that the probability of
two independent events is the product of their probabilities: $p(a, b) = p(a)p(b)$.
  \end{itemize}
\end{proposition}
\begin{proof}
  We check the laws:
  \begin{itemize}
  \item If we push forward a distribution $p = \sum_{a \in X}\lambda_a a$ along
    $\eta_A : A \to \probset A$, we get
    \[
    \eta_A^{\probset}(p) = \sum_{a \in X} \sum_{a' \in \{a\}} 1\cdot
    \lambda_{a'}  a' = \sum_{a \in X}\lambda_a a.
\]
  \item For a stochastic map $f : A \to \probset B$, we aim to show that pushing
    forward the Dirac delta distribution $\eta_A(a)$ along $f$ gives $f(a) =
    \sum_{b \in Y_a} \lambda_{b a} b$. The definition of push forward gives us
    \[
f^{\probset}(\eta_A(a)) = \sum_{a' \in \{a\}}\sum_{b \in Y_{a'}}
\lambda_{ba} \cdot 1 \cdot b = \sum_{b \in Y_a} \lambda_{ba} b.
    \]
   \item Given stochastic functions $f : A \to \probset B$ and $g : B \to
     \probset C$, we need to show that $g^{\probset}(f^{\probset}(p)) =
     (g^{\probset}\circ f)^{\probset}(p)$. Let
\begin{align*}
 p &= \sum_{a \in X} \lambda_{a}, \\
f(a) &= \sum_{b \in Y_a} \rho_{ba} b, \\
g(b) &= \sum_{c \in Z_b} \gamma_{cb} c.
\end{align*}
       Then we see that
       \[
g^{\probset}(f(a)) = \sum_{c \in \bigcup_{b \in \bigcup_{a \in X} Y_a }} \gamma_{cb} \rho_{ba} c
       \]
       so that, finally
\begin{align*}
  g^{\probset}(f^{\probset}(p)) &= g^{\probset}\left( \sum_{a \in X} \sum_{b \in Y_a} \rho_{ba} \lambda_a c \right) \\
                                &=  \sum_{a \in X} \sum_{b \in Y_a} \sum_{c \in Z_b} \gamma_{cb} \rho_{ba} \lambda_a c \\
  &= (g^{\probset}\circ f)^{\probset}(p). 
\end{align*}
  \end{itemize}

  Next, we check that the laws of a commutative monad hold. We note that for a
  function $f : A \to B$, the function $\probset f = (\eta_B \circ
  f)^{\probset}$ is defined by
  \[\probset f\left( \sum_{a \in X} \lambda_a a \right) = \sum_{a \in X} \sum_{b
    \in \{f(a)\}} \lambda_a b = \sum_{a \in X} \lambda_a f(a).\]
  Furthermore, $\mu : \probset^2 A \to \probset A$ sends a formal convex
  combination $\sum_i \lambda_i p_i$ of probability distributions to the
  \emph{actual} convex combination of those probability distributions, namely
  the distribution
  \[
\mu\left( \sum_i \lambda_i p_i \right)(a) \coloneqq \sum_i \lambda_i p_i(a).
  \]
  
  \begin{itemize}
\item (\cref{eqn.com_monad_right_unit}) The unit on $\ord{1} \cong \{\ast\}$
  sends $\ast$ to the distribution $1 \cdot \ast$. So, $\sigma(p, 1) = \sum_{(a, \ast) \in X \times
    \ord{1}} \lambda_a \cdot 1 \cdot (a, \ast)$, and projecting out again gives
  us $p = \sum_{a \in X} \lambda_a a$.
\item (\cref{eqn.com_monad_left_unit}) The same, but on the other side.
\item (\cref{eqn.com_monad_assoc}) Suppose that we have
  \begin{align*}
    p &= \sum_{a \in X} p_a a, \\
    q &= \sum_{b \in Y} q_b b, \\
    r &= \sum_{c \in Z} r_c c.
  \end{align*}
  The both paths of \cref{eqn.com_monad_assoc} give us the distribution
  \[
\sum_{(a, b, c) \in X \times Y \times Z} p_a q_b r_c (a, b, c).
  \]
  \item (\cref{eqn.com_monad_monad_unit}) This is asking whether $\delta_{(a,
      b)} = \delta_a \delta_b$ as distributions on $A \times B$, which they are.
  \item (\cref{eqn.com_monad_monad_mult}) Let $\sum_{i} \lambda_i p_i$ be an
    element of $\probset\probset A$, and similarly let $\sum_j \rho_j q_j$ be an
    element of $\probset\probset B$. Following the bottom path around, we get
    \[
\sigma\left( \mu\left( \sum_i \lambda_i p_i \right), \mu\left( \sum_j \rho_j q_j
  \right) \right)(a, b) = \left( \sum_i \lambda_i p_i(a) \right)\left( \sum_j
  \rho_j q_j(b) \right) = \sum_i \sum_j \lambda_i \rho_j p_i(a)q_j(b).
    \]
    Meanwhile,
    \[\sigma\left( \sum_i \lambda_i p_i, \sum_j \rho_j q_j \right) =
      \sum_i \sum_j \lambda_i \rho_j (p_i, q_j).
    \]
    and taking $\probset \sigma$ of that gives
    \[
\sum_i \sum_j \lambda_i \rho_j p_i q_j
\]
which means that finally
\[
\mu\left(\probset \sigma\left( \sigma\left( \sum_i \lambda_i p_i, \sum_j \rho_j
      q_j \right) \right) \right)(a, b) = \sum_i \sum_j \rho_j p_i(a)q_j(b).
\]
  \end{itemize}

\end{proof}

\begin{exercise}
  Let $f : \ord{n} \to \probset \ord{m}$ and $g : \ord{m} \to \probset \ord{k}$
  be stochastic maps. Note that we can interpret $f$ as an $m \times n$
  stochastic matrix $F$, and similarly $g$ as a $k \times m$ stochastic matrix $G$. Show
  that the stochastic map $g^{\probset} \circ f$ is associated to the stochastic
  matrix $GF$.
\end{exercise}

Just as the commutative monad structure of $\powset$ helped us iterate possibilistic systems
and get the set of possible output values from them, so the commutative monad
structure of $\probset$ helps us iterate stochastic systems and get a
probability distribution of likely output values from them.

Given a stochastic system $\Sys{S}$, we have $\update{S} : \State{S} \times
\In{S} \to \probset \State{S}$. From this, we can get a stochastic map:
\[
\probset\State{S} \times \In{S} \xto{\id \times \eta} \probset\State{S} \times
\probset\In{S} \xto{\sigma} \probset(\State{S} \times \In{S})
\xto{\update{S}^{\probset}} \probset{\State{S}}
\]
which will let us iterate. We can see that this sends a probability distribution
$p$ on states and an input $i$ to the distribution
\[
s \mapsto \sum_{s' \in \State{S}} p(s') \update{S}(s', i)(s).
\]

\section{Monadic doctrines and the Kleisli category}\label{sec.monad_doctrine}
We have now seen two sorts of non-determinism expressed by commutative monads.
To each of these we associated a doctrine:
\begin{itemize}
  \item To the powerset monad $\powset$, we associated the doctrine of
    possibilistic systems. This is because a map $f : A \to \powset B$ is a
    \emph{possibilistic map} --- it assigns
    a set of \emph{possible images} to each element $a \in A$. 
  \item To the probability distribution monad $\probset$, we associated the
    doctrine of stochastic system. This is because a map $f : A \to \probset B$
    is a stochastic map.
\end{itemize}
In general, for any commutative monad $M$ we call a map of the form $f : A \to
MB$ a \emph{Kleisli map}. The structure of a monad on $M$ lets us compose
Kleisli maps, giving us the \emph{Kleisli category} of the monad. The
commutativity then makes the Kleisli category into a symmetric monoidal category.
\begin{definition}
  Let $M : \cat{C} \to \cat{C}$ be a commutative monad on a cartesian category. The \emph{Kleisli category} $\Cat{Kl}(M)$ is
  defined as follows:
  \begin{itemize}
    \item The objects of $\Cat{Kl}(M)$ are the same as those of $\cat{C}$.
    \item A map $f : A \wavyto B$ in $\Cat{Kl}(M)$ is a map $f : A \to MB$ in $\cat{C}$.
    \item The identity $\id_A : A \wavyto A$ is $\eta_A : A \to MA$.
    \item For $f : A \wavyto B$ and $g : B \wavyto C$, their composite is $f
      \then g^M : A \to MC$. In do notation, the Kleisli composite is given by 
\[
(f \then g)(a) \coloneqq \unalignedDo{
  $b \from f(a)$,
  $g(b)$
}.
\]

 Since $g^M = Mg \then \mu$, the Kleisli composite
      may be equivalently defined
      as $f \then Mg \then \mu$.
  \end{itemize}
  The Kleisli category of $M$ becomes a symmetric monoidal structure with with
  the tensor $A \times B$ and $\ord{1}$. Note that although $A \times B$ is
  cartesian in $\cat{C}$, it will rarely be cartesian in $\Cat{Kl}(M)$.
\end{definition}

We can understand Kleisli composition a bit better if we introduce a graphical
language for monads.\footnote{If you know of it, this is just the usual string
  diagram language for 2-categories.} This will also help us later in \cref{sec.bikleisli} when
we learn about \emph{biKleisli} composition. We will draw an object of our category
$X \in \cat{C}$ as a string:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (1, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (0.center) to (1.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
and a map $f : X \to Y$ as a bead:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (1, 0) {};
		\node [style=function clear] (2) at (0, 0) {$f$};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (0.center) to (1.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
Composition is drawn by connecting strings, and the identity map on $X$ is represented
by the same string which represents $X$. 
We will draw our monad $M : \cat{C} \to \cat{C}$ as a red string:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (1, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red] (0.center) to (1.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
We can draw the natural transformations $\eta : \id_{\cat{C}} \Rightarrow M$ and
$\mu : M^2 \Rightarrow M$ as
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function red] (0) at (0, 0) {};
		\node [style=none] (3) at (1, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red] (0) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
\quad\mbox{and}\quad
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (0, 0) {};
		\node [style=none] (1) at (-1, 0.5) {};
		\node [style=none] (3) at (1, 0) {};
		\node [style=none] (7) at (-1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red] (0.center) to (3.center);
		\draw [style=object red, bend left, looseness=0.75] (1.center) to (0.center);
		\draw [style=object red, bend right, looseness=0.75] (7.center) to (0.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
respectively. The laws \cref{eqn.monad_laws} can be written as:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (0, 0) {};
		\node [style=none] (1) at (-1, -0.5) {};
		\node [style=none] (3) at (1, 0) {};
		\node [style=function red] (8) at (-1, 0.5) {};
		\node [style=none] (12) at (-2, -0.5) {};
		\node [style=none] (13) at (-1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red] (0.center) to (3.center);
		\draw [style=object red, bend right, looseness=0.75] (1.center) to (0.center);
		\draw [style=object red, bend left, looseness=0.75] (8) to (0.center);
		\draw [style=object red] (12.center) to (13.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (0, 0) {};
		\node [style=none] (1) at (-1, 0.5) {};
		\node [style=none] (3) at (1, 0) {};
		\node [style=function red] (8) at (-1, -0.5) {};
		\node [style=none] (12) at (-2, 0.5) {};
		\node [style=none] (13) at (-1, 0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red] (0.center) to (3.center);
		\draw [style=object red, bend left, looseness=0.75] (1.center) to (0.center);
		\draw [style=object red, bend right, looseness=0.75] (8) to (0.center);
		\draw [style=object red] (12.center) to (13.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (0, 0) {};
		\node [style=none] (1) at (-1, -0.5) {};
		\node [style=none] (3) at (1, 0) {};
		\node [style=none] (8) at (-1, 0.5) {};
		\node [style=none] (9) at (-2, 0) {};
		\node [style=none] (11) at (-2, 1) {};
		\node [style=none] (12) at (-2, -0.5) {};
		\node [style=none] (13) at (-1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red] (0.center) to (3.center);
		\draw [style=object red, bend right, looseness=0.75] (1.center) to (0.center);
		\draw [style=object red, bend right, looseness=0.75] (9.center) to (8.center);
		\draw [style=object red, bend left, looseness=0.75] (11.center) to (8.center);
		\draw [style=object red, bend left, looseness=0.75] (8.center) to (0.center);
		\draw [style=object red] (12.center) to (13.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (0, 0) {};
		\node [style=none] (1) at (-1, 0.5) {};
		\node [style=none] (3) at (1, 0) {};
		\node [style=none] (8) at (-1, -0.5) {};
		\node [style=none] (9) at (-2, 0) {};
		\node [style=none] (11) at (-2, -1) {};
		\node [style=none] (12) at (-2, 0.5) {};
		\node [style=none] (13) at (-1, 0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red] (0.center) to (3.center);
		\draw [style=object red, bend left, looseness=0.75] (1.center) to (0.center);
		\draw [style=object red, bend left, looseness=0.75] (9.center) to (8.center);
		\draw [style=object red, bend right, looseness=0.75] (11.center) to (8.center);
		\draw [style=object red, bend right, looseness=0.75] (8.center) to (0.center);
		\draw [style=object red] (12.center) to (13.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]

The map $Mf : MX \to MY$ on objects is written:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (1, 0) {};
		\node [style=function clear] (2) at (0, 0) {$f$};
		\node [style=none] (3) at (-1, -0.5) {};
		\node [style=none] (4) at (1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (0.center) to (1.center);
		\draw [style=object red] (3.center) to (4.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
Note that functoriality is baked in to this string diagram notation; the
following diagram could either be interpreted as $Mf \then Mg$ or $M(f \then
g)$, which are equal by the functoriality of $M$:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (1, 0) {};
		\node [style=function clear] (2) at (0, 0) {$f$};
		\node [style=none] (3) at (-1, -0.5) {};
		\node [style=none] (4) at (1, -0.5) {};
		\node [style=none] (5) at (1, 0) {};
		\node [style=none] (6) at (3, 0) {};
		\node [style=function clear] (7) at (2, 0) {$g$};
		\node [style=none] (8) at (1, -0.5) {};
		\node [style=none] (9) at (3, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (0.center) to (1.center);
		\draw [style=object red] (3.center) to (4.center);
		\draw [style=object] (5.center) to (6.center);
		\draw [style=object red] (8.center) to (9.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
The naturality of $\eta$ and $\mu$ is also baked into this notation; it just
means we can move them independently of the beads representing functions:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (2, 0) {};
		\node [style=function clear] (2) at (0, 0) {$f$};
		\node [style=none] (3) at (1, -1) {};
		\node [style=none] (4) at (-1, -0.5) {};
		\node [style=none] (5) at (2, -1) {};
		\node [style=none] (6) at (-1, -1.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (0.center) to (1.center);
		\draw [style=object red] (3.center) to (5.center);
		\draw [style=object red, bend left=15, looseness=0.75] (4.center) to (3.center);
		\draw [style=object red, bend right=15, looseness=0.75] (6.center) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (2, 0) {};
		\node [style=function clear] (2) at (1, 0) {$f$};
		\node [style=none] (3) at (0, -1) {};
		\node [style=none] (4) at (-1, -0.5) {};
		\node [style=none] (5) at (2, -1) {};
		\node [style=none] (6) at (-1, -1.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (0.center) to (1.center);
		\draw [style=object red] (3.center) to (5.center);
		\draw [style=object red, bend left=15, looseness=0.75] (4.center) to (3.center);
		\draw [style=object red, bend right=15, looseness=0.75] (6.center) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
With these conventions in hand, we can now represent a Kleisli map $f : X \to
MY$ as
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (0, 0) {$f$};
		\node [style=none] (1) at (-1, 0) {};
		\node [style=none] (2) at (1, 0) {};
		\node [style=none] (3) at (1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (0) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
The unit $\eta : X \to MX$ is written
\[
\begin{tikzpicture}
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (1) at (-1, 0) {};
		\node [style=none] (2) at (1, 0) {};
		\node [style=none] (3) at (1, -0.5) {};
		\node [style=function red] (4) at (0, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (2.center);
		\draw [style=object red] (4) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
The composition of Kleisli maps $f : X \to MY$ and $g : Y \to MZ$ is then given
by
\[
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (-1, 0) {$f$};
		\node [style=none] (1) at (-2, 0) {};
		\node [style=none] (2) at (0, 0) {};
		\node [style=none] (3) at (1.75, -1.5) {};
		\node [style=function clear] (4) at (1, 0) {$g$};
		\node [style=none] (5) at (0, 0) {};
		\node [style=none] (6) at (3.5, 0) {};
		\node [style=none] (8) at (2.5, -1) {};
		\node [style=none] (9) at (1.75, -0.5) {};
		\node [style=none] (10) at (3.5, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (0) to (3.center);
		\draw [style=object] (5.center) to (4);
		\draw [style=object] (4) to (6.center);
		\draw [style=object red] (8.center) to (10.center);
		\draw [style=object red, bend left, looseness=0.75] (9.center) to (8.center);
		\draw [style=object red, bend right, looseness=0.75] (3.center) to (8.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (4) to (9.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
We can use these string diagrams to easily check that $\Cat{Kl}(M)$ is actually
a category. We use the monad laws \cref{eqn.monad_laws}:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (-2, 0) {};
		\node [style=none] (2) at (0, 0) {};
		\node [style=none] (3) at (1.75, -1.5) {};
		\node [style=function clear] (4) at (1, 0) {$f$};
		\node [style=none] (5) at (0, 0) {};
		\node [style=none] (6) at (3.5, 0) {};
		\node [style=none] (7) at (2.5, -1) {};
		\node [style=none] (8) at (1.75, -0.5) {};
		\node [style=none] (9) at (3.5, -1) {};
		\node [style=function red] (10) at (-1, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0.center);
		\draw [style=object] (0.center) to (2.center);
		\draw [style=object] (5.center) to (4);
		\draw [style=object] (4) to (6.center);
		\draw [style=object red] (7.center) to (9.center);
		\draw [style=object red, bend left, looseness=0.75] (8.center) to (7.center);
		\draw [style=object red, bend right, looseness=0.75] (3.center) to (7.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (4) to (8.center);
		\draw [style=object red, in=180, out=0, looseness=1.25] (10) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (0, 0) {$f$};
		\node [style=none] (1) at (-1, 0) {};
		\node [style=none] (2) at (1, 0) {};
		\node [style=none] (3) at (1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (0) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (-1, 0) {$f$};
		\node [style=none] (1) at (-2, 0) {};
		\node [style=none] (2) at (0, 0) {};
		\node [style=none] (3) at (1.75, -1.5) {};
		\node [style=none] (4) at (1, 0) {};
		\node [style=none] (5) at (0, 0) {};
		\node [style=none] (6) at (3.5, 0) {};
		\node [style=none] (8) at (2.5, -1) {};
		\node [style=function red] (9) at (1.75, -0.5) {};
		\node [style=none] (10) at (3.5, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (0) to (3.center);
		\draw [style=object] (5.center) to (4.center);
		\draw [style=object] (4.center) to (6.center);
		\draw [style=object red] (8.center) to (10.center);
		\draw [style=object red, bend left, looseness=0.75] (9) to (8.center);
		\draw [style=object red, bend right, looseness=0.75] (3.center) to (8.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (-2.75, 0) {$f$};
		\node [style=none] (1) at (-3.75, 0) {};
		\node [style=none] (2) at (-1.75, 0) {};
		\node [style=none] (3) at (0, -1.5) {};
		\node [style=function clear] (4) at (-0.75, 0) {$g$};
		\node [style=none] (5) at (-1.75, 0) {};
		\node [style=none] (7) at (0.75, -1) {};
		\node [style=none] (8) at (0, -0.5) {};
		\node [style=none] (9) at (2.25, -1) {};
		\node [style=function clear] (10) at (1.25, 0) {$h$};
		\node [style=none] (12) at (3.5, 0) {};
		\node [style=none] (13) at (2.25, -0.5) {};
		\node [style=none] (14) at (2.25, -1) {};
		\node [style=none] (15) at (3, -0.75) {};
		\node [style=none] (16) at (2.25, -0.5) {};
		\node [style=none] (17) at (3.5, -0.75) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (0) to (3.center);
		\draw [style=object] (5.center) to (4);
		\draw [style=object red] (7.center) to (9.center);
		\draw [style=object red, bend left, looseness=0.75] (8.center) to (7.center);
		\draw [style=object red, bend right, looseness=0.75] (3.center) to (7.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (4) to (8.center);
		\draw [style=object] (10) to (12.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (10) to (13.center);
		\draw [style=object] (4) to (10);
		\draw [style=object red, bend left, looseness=0.75] (16.center) to (15.center);
		\draw [style=object red, bend right, looseness=0.75] (14.center) to (15.center);
		\draw [style=object red] (15.center) to (17.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (-2.75, 0) {$f$};
		\node [style=none] (1) at (-3.75, 0) {};
		\node [style=none] (2) at (-1.75, 0) {};
		\node [style=none] (3) at (2.25, -1.5) {};
		\node [style=function clear] (4) at (-0.75, 0) {$g$};
		\node [style=none] (5) at (-1.75, 0) {};
		\node [style=none] (8) at (2.25, -1) {};
		\node [style=none] (9) at (2.25, -1) {};
		\node [style=function clear] (10) at (1.25, 0) {$h$};
		\node [style=none] (12) at (4.5, 0) {};
		\node [style=none] (13) at (2.25, -0.5) {};
		\node [style=none] (14) at (2.25, -1) {};
		\node [style=none] (15) at (3, -0.75) {};
		\node [style=none] (16) at (2.25, -0.5) {};
		\node [style=none] (17) at (3.75, -1) {};
		\node [style=none] (18) at (4.5, -1) {};
		\node [style=none] (19) at (2.25, -1.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (0) to (3.center);
		\draw [style=object] (5.center) to (4);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (4) to (8.center);
		\draw [style=object] (10) to (12.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (10) to (13.center);
		\draw [style=object] (4) to (10);
		\draw [style=object red, bend left, looseness=0.75] (16.center) to (15.center);
		\draw [style=object red, bend right, looseness=0.75] (14.center) to (15.center);
		\draw [style=object red, in=135, out=0] (15.center) to (17.center);
		\draw [style=object red] (17.center) to (18.center);
		\draw [style=object red, bend right, looseness=0.75] (19.center) to (17.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]


\begin{example}\label{ex.powerset_kleisli}
  The Kleisli category $\Cat{Kl}(\powset)$ of the powerset monad $\powset$ is
  the category of \emph{multi-valued maps}. A Kleisli map $f : A \to
  \powset B$ assigns to each $a \in A$ a subset $f(a) \subseteq B$ of possible
  images of $a$. Given another Kleisli map $g : B \to \powset C$, their
  composite in the Kleisli category $g^{\powset} \circ f : A \to \powset C$
  sends $a \in A$ to the union $\bigcup_{b \in f(a)} g(b)$. In other words, a
  possible image of $g \circ f$ is any possible image of $g$ of any possible
  image of $f$.
\end{example}

\begin{example}\label{ex.probset_kleisli}
  The Kleisli category $\Cat{Kl}(\probset)$ of the probability monad $\probset$
  is the category of \emph{stochastic maps}. A Kleisli map $f : A \to \probset
  B$ assigns to each $a \in A$ a probability distribution $f(a)$ on $B$. Given
  another Kleisli map $g : B \to \probset C$, their composite $g^{\probset}
  \circ f : A \to \probset C$ in the Kleisli category sends $a$ to the
  probability distribution $c \mapsto \sum_{b \in B}
  f(a)(b) \cdot g(b)(c)$. That is, since $c$ is the image of $a$ under $g \circ f$ if there is a $b$ which
  is the image of $a$ under $f$ and $c$ is the image of $b$ under $g$, the
  probability that $c$ is the image of $a$ is the probability of their being
  such a $b$.

  Thinking of stochastic maps as conditional probabilities, where $f : A \to
  \probset B$ expresses the conditional probability $p(b \mid a) = f(a)(b)$,
  then we see that
  $p(c \mid a) = \sum_{b \in B} p(b \mid a) p(c \mid b)$
  as we expect from conditional probabilities.
\end{example}


Now we encompass all our non-deterministic examples in a single definition.
\begin{definition}\label{def.monadic_system}
Let $M : \cat{C} \to \cat{C}$ be a commutative monad. A (discrete-time)
$M$-system $\Sys{S}$, also written as   
  $$\lens{\update{S}}{\expose{S}} : \lens{\State{S}}{\State{S}} \leftrightarrows \lens{\In{S}}{\Out{S}},$$ 
is a system whose dynamics is given by a Kleisli map for $M$. It consists of:
  \begin{itemize}
    \item an object $\State{S}$ of \emph{states};
    \item an object $\Out{S}$ of \emph{values for exposed variables}, or \emph{outputs}
      for short;
    \item an object $\In{S}$ of \emph{parameter values}, or \emph{inputs} for short;
    \item a map $\expose{S} : \State{S} \to \Out{S}$, the \emph{exposed variable of state} or
      \emph{expose} map, which takes a state to the output it yields; and
    \item a Kleisli map $\update{S} : \State{S} \times \In{S} \to
     M\State{S}$. This is the \emph{dynamics} or
      \emph{update} map which takes a state and a parameter and gives the
      next state in a non-deterministic way determined by $M$.
  \end{itemize}
\end{definition}

This will let us more swiftly describe new non-deterministic doctrines.

For
example, suppose that our system is free to choose which state it transitions
to next, but there's a catch. For any state $s$ and input parameter $i$, there
will be a cost $\update{S}(s, i)(s') \in [0, \infty]$ associated to each other state $s'$ ---
the cost of transitioning from $s$ to $s'$ given the parameter $i$. A cost of
$0$ means that this transition is free; a cost of $\infty$ means it is
prohibitively expensive, or impossible.


\begin{definition}\label{def.cost_monad}
  We will define a monad $\Fun{Cost}$ on the category of sets. We think of a Kleisli map $f : A \to \Fun{Cost} ( B )$ as
  assiging the best-case cost of producing a $b \in B$ from a given $a \in A$.
  For practical reasons, we assume that only finitely many $b \in B$ are
  possible (that is, have finite cost) to produce from an $a \in A$.

  \begin{itemize}
  \item For a set $A$,
    \[
\Fun{Cost}(A) \coloneqq \{c : A \to [0, \infty] \mid \mbox{$\{a \in A \mid c(a) <
  \infty\}$ is finite}\}
    \]
    is the set of cost functions $c : A \to [0, \infty]$ which assign finite
    values to only finitely many elements of $A$.
  \item For a set $A$, $\eta^{\Fun{Cost}} : A \to \Fun{Cost}(A)$ assumes that we
    can only produce what we have, but that if we already have it, it's free. Formally:
\[
\eta^{\Fun{Cost}}(a)(a') \coloneqq \begin{cases} 0 &\mbox{if $a = a'$} \\
  \infty &\mbox{otherwise}\end{cases}
\]

  \item For a map with cost $f : A \to \Fun{Cost}(B)$, we define
      $f^{\Fun{Cost}} : \Fun{Cost}(A) \to \Fun{Cost}(B)$ by
      \[
f^{\Fun{Cost}}(c)(b) \coloneqq \min_{a \in A} c(a) + f(a)(b).
      \]
That is, given costs on elements of $A$ and conditional costs on elements of $B$
given by $f$, the cost of an element of $B$ is the cost of getting an $a \in A$
together with the cost of producing $b$ from that $a$. So, the best case cost of
such a $b$ is the minimum over all $a \in A$ of the total cost of producing $b$
from $a$. We note that the minimum is achieved because only finitely many of the
costs are finite.
  \item Given sets $A$ and $B$, the cost of having an element of $A$ and an
    element of $B$ is the sum of their costs.
    $$\sigma(c, c')(a, b) \coloneqq c(a) + c'(b).$$
  \end{itemize}
\end{definition}

\begin{remark}
We will prove that \cref{def.cost_monad} does indeed give a commutative monad in
the upcoming \cref{ex.rig_monad}.
\end{remark}

Now we can quickly define our new sort of non-determinism.
\begin{definition}\label{def.system_with_costs}
A (discrete-time) system with costs is a $\Fun{Cost}$-system.
\end{definition}


\begin{example}
  Suppose we are trying to complete a project $\Sys{Proj}$ that involves a number of steps.
  Let $\Set{Steps}$ be the set of steps involved. The state of our project at any given
  time is the set of steps we have completed so far: $\State{Proj} \coloneqq
  \powset\Set{Steps}$. Now, we may not want to show everyone exactly how our
  project is going, just that it has hit certain milestones. So we can let
  $\Out{Proj} \coloneqq \Set{Milestones}$ be our set of milestones and
  $\expose{Proj} : \State{Proj} \to \Out{Proj}$ send each project state to the
  most recent milestone completed.

  Now, in any project, there are some external conditions
  to be dealt with. Let $\In{Proj} = \Set{Externalities}$
  be the set of these externalities. We can assume that there is a cost
  associated to choosing a next step to take which depends not only on what
  steps have been completed so far but also on the current external conditions:
  that is, we can assume we have a function $\fun{cost} : \State{Proj} \times
  \In{Proj} \to \Fun{Cost}(\Set{Steps})$, and that $\fun{cost}(s, i)(x) = 0$
  whenever $x \in s$ is a step we have already completed.\footnote{Although one
    could imagine this instead as a ``maintenance'' cost of maintaining the
    completion of that step.} Given this, we can define the update
  of our project system as
  \[
\update{Proj}(s, i)(s') \coloneqq \sum_{x \in s'} \fun{cost}(s,
  i)(x).
  \]
  This tells us that the cost moving from having completed the steps $s$ to
  having completed the steps $s'$ given external conditions $i$ is the sum of
  the cost of completing each step in $s'$ which is not in $s$.

  The crucial question we want to ask of this model is: how much will the
  project cost in the best case scenario, given a sequence of external
  conditions? That is, we will iterate the action of the system through the
  sequence of paramters starting at
  $\emptyset \in \State{Proj}$, and then ask the cost of $\Set{Steps} \in
  \State{Proj}$ at the end. 
\end{example}

We took $\Fun{Cost}$ to be the monad of best case costs. Let's show that there
is also a monad $\Fun{Cost}^{\max}$ of worst case costs. Everything will be the same, but instead of
\[f^{\Fun{Cost}}(c)(b) \coloneqq \min_{a \in A} c(a) + f(a)(b),\]
we will have
\[
f^{\Fun{Cost}^{\max}}(c)(b) \coloneqq \max_{a \in A} c(a) + f(a)(b).
\]
It is worth noting that this formula has a formal similarity to the following
formula:
\[
f^{R}(c)(b) \coloneqq \sum_{a \in A} c(a)\cdot f(a)(b).
\]
which resembles matrix multiplication. This is indeed the case; for any sort of
(commutative) scalars, we get a monad that reproduces matrix arithmetic with
those scalars. An appropriate set of scalars is called a \emph{commutative rig}.

\begin{definition}
A \emph{commutative rig} (for ``ri{\textbf{n}}g without
{\textbf{n}}egatives''\footnote{Rigs are also sometimes referred to as ``semirings''.}) is a set $R$
equipped with an abelian group structure $(R, +, 0)$ and a commutative monoid structure $(R,
\cdot, 1)$ such that
\[
a \cdot (b + c) = a \cdot b + a \cdot c
\]
for all $a,\, b,\, c\in R$.
\end{definition}

\begin{example}
  The following are important examples of rigs:
  \begin{enumerate}
    \item The natural numbers $\nn$ with their usual addition and multiplication
      form a rig. Similarly, the non-negative rationals and reals form rigs with
      their usual addition and multiplication. 
    \item Any ring is a rig. In particular, $\zz$, $\mathbb{Q}$, and $\rr$ are all rigs
      with their usual addition and multiplication.
    \item The \emph{tropical rigs} are rigs where ``addition'' is actually
      minimum or maximum, and ``multiplication'' is actually addition. In
      particular, the \emph{rig of best-case costs} $[0, \infty]$ is a rig with $\min$ as its addition and $+$ as
      its multiplication. In this rig, distributivity looks like
      \[
a + \min\{b, c\} = \min\{a + b, a + c\},
      \]
      and a linear combination looks like
      \[ \min_{i \in I} c_i + x_i.\]
      The additive unit is $\infty$, and the multiplicative unit is $0$.

      Similarly, there is a \emph{rig of worst-case costs} on $[0,\infty]$ with
      $\max$ as addition and $+$ as multiplication. This rig is remarkable in
      that its additive and multiplicative unit are the same; they are both $0$.
   \item In fact, any ordered commutative monoid $(M, +, 0, \leq)$ (where if $a \leq
     b$, then $c + a \leq c + b$) which admits joins $a \vee b$ (that is, least
     upper bounds) can be made into a commutative rig with addition given by
     $\vee$ and multiplication given by $+$.
  \end{enumerate}
\end{example}

\begin{proposition}
  For any commutative rig $R$, there is a commutative monad $R \otimes - :
  \smset \to \smset$ defined by
  \begin{itemize}
    \item $R \otimes X$ is the set of $R$-linear combinations of elements of
      $X$.
    \item $\eta : X \to R \otimes X$ sends $x$ to the linear combination $
      \cdot x$.
    \item For $f : X \to R \otimes Y$, we have $f^{R} : R \otimes X \to R
      \otimes Y$ defined by
      \[
f^R\left( \sum_{i}r_i x_i \right) = \sum_{i} r_i f(x_i).
\]
    \item For sets $X$ and $Y$, we have $\sigma : (R \otimes X) \times (R
      \otimes Y) \to R \otimes (X \times Y)$ defined by
      \[
\sigma\left( \sum_i r_i x_i,\, \sum_j s_j y_j \right) = \sum_{i}\sum_{j} r_i s_j
(x_i, y_j).
      \]
  \end{itemize}
\end{proposition}



\section{Adding rewards to non-deterministic systems}

A common way to think of a discrete-time system is as a \emph{decision process}. We
think of the system $\Sys{A}$ as an \emph{agent} who needs to make a decision.
The agent can choose an \emph{action}, an element of $\In{A}$, and will then
transition into a new state --- although it may not know precisely which. We
then ask the question: what is the best action for the agent to take in a given
situation?

Clearly, an answer to this question will depend on what it means for one action
to be better than another. The most common way to model this is by associating
each action with a real number \emph{reward}. The bigger the reward, the better
the action (and negative rewards are harmful actions). If the agent is going to
take a sequence of actions, we want the rewards to accumulate so that the total
reward of a sequence of actions is the sum of each reward.

We can handle this accumulation of rewards, even in a deterministic system, with
a commutative monad.

\begin{definition}
Let $(R, +, 0)$ be a commutative monoid (such as the real numbers). The
\emph{$R$-valued reward monad} or \emph{monad of $R$-actions} is defined by the
following data:
\begin{itemize}
  \item To each set $A$, we associate the set $R \times A$ of pairs of a reward
    and an element of $A$.
  \item For each set $A$, we have $\eta_A : A \to R \times A$ given by yielding
    no reward:
    $\eta_A(a) = (0, a).$
  \item For a function $f : A \to R \times B$ which yields an element of $B$ and
    a reward, we give the function
    \[
      f^R : R \times A \to R \times B
    \]
 defined by $f^R(r, a) = (r + \pi_1f(a), \pi_2f(a))$. This accumulates the
 reward $\pi_1f(a)$ from applying $f$ to $a$ onto a current reward $r$
\item For sets $A$ and $B$, we have
  \[
\sigma : (R \times A) \times (R \times B) \to R \times (A \times B)
\]
given by $\sigma((r, a), (r', b)) = (r + r', (a, b))$. The reward for doing two
actions simultaneously is the sum of their rewards.
  \end{itemize}
  
We remark that this works not only in the category of sets, but in any cartesian category.
\end{definition}

\begin{exercise}
  Show that the monad of $R$-valued rewards is really a commuativative monad.
  That is, show that the above data satisfies all each of the laws in
  \cref{def.commutative_monad}. Do you see where the commutativity comes into
  the mix?
\end{exercise}

We can then describe a system with reward as having an update $\update{S} :
\State{S} \times \In{S} \to R \times \State{S}$ which sends the current state
and action to the next state together with the reward for taking that action (in
that state).

\begin{definition}
A deterministic system with $R$-valued rewards is an $(R \times -)$-system in
the sense of \cref{def.monadic_system}
\end{definition}

We would really like to mix our rewards with non-determinism. In particular,
when thinking of a system as an agent making decisions with imperfect
information of its environment, we would like to use stochastic systems to model
this lack of perfect information. The agent doesn't know exactly what will
happen when it performs an action, but it has a good idea of what will
\emph{probably} happen.


The reward our agent gets should depend on what state the
agent actually ends up in, and not just the action it takes. Therefore, we want to know the probability of transitioning to a next state \emph{and}
getting a certain reward. This has signature
\[
  \State{S} \times \In{S} \to \probset(\rr \times \State{S}).
\]

We will show that the assignment $A \mapsto \probset(\rr \times A)$
 forms a commutative monad. We will show that more generally, if $M$ is
 \emph{any} commutative monad and $R$ any commutative monoid, then $M(R \times
 -)$ is a commutative monad again. We say that we can ``put the rewards $R$ into
 the monad $M$''. We can do this explicitly using the map $\lambda : R \times MA
 \to M(R \times A)$ defined to be the composite
 \[
\lambda \coloneqq R \times MA \xto{\eta^M \times \id} MR \times MA \xto{\sigma^M} M(R \times A)
 \]
Intuitively, this takes a reward $r \in R$ and a non-deterministic $a \in MA$
and gives us the non-determinstic pair $(r, a)$.
 
\begin{proposition}
Let $M$ be a commutative monad and $(R, +, 0)$ a commutative monoid. Then the
assignment $A \mapsto M(R \times A)$ is a commutative monad with the following
structure:
\begin{itemize}
  \item $\eta^{M(R\times -)} : A \to M(R \times A)$ is the composite $A
    \xto{\eta^R} R \times A \xto{\eta^M} M(R \times A)$.
  \item Given $f : A \to M(R \times B)$, we define $f^{M(R \times -)}$ to be the
    following composite:
    \begin{multline*}
M(R \times A) \xto{M(R \times f)} M(R \times M(R \times B)) \xto{M\lambda} MM(R \times R \times B)\\\xto{\mu^{M}} M(R \times R \times B) \xto{M\mu^R} M(R \times B).
      \end{multline*}
 Intuitively, this takes a non-deterministic pair $(r, a)$ and, gets the
 non-deterministic pair $f(a) = (f_1(a), f_2(a))$, and then returns the
 non-deterministic pair $(r + f_1(a), f_2(a))$.
  \item Given sets $A$ and $B$, we define $\sigma^{M(R \times -)} : M(R \times
    A) \to M(R \times B)$ to be the composite
    \[
M(R \times A) \xto M(R \times B) \xto{\sigma^M} M((R \times A) \times (R \times
B)) \xto{M\sigma^R} M(R \times A \times B).
    \]
\end{itemize}
\end{proposition}
\begin{proof}
It is not obvious that this will satsify the monad laws, but it is a rather
straightforward check using the laws of $M$ and $R \times -$. We will not prove
this result explicitly. However, we will give a slick proof for experts.

A monad structure on $M(R \times A)$ arising via a distributive law such as
$\lambda : R \times MA \to M(R \times A)$ is equivalent to a lift of the monad
$M$ to the category of $R \times -$ algebras --- that is, the category of
$R$-actions. But $M : \cat{C} \to \cat{C}$ is a commutative monad, and so in particular it is a
symmetric monoidal functor; therefore, it preserves commutative monoids and
their actions. For this reason, $M$ extends to the category of $(R \times -)$-algebras, giving
us the desired monad structure on $M(R \times -)$. This is again commutative as
it is the composite of monoidal functors and so also monoidal.
\end{proof}

\begin{example}
Let's see what this general theorem looks like in the case that $R = \rr$ and $M
= \probset$. In this case, $\lambda : \rr \times \probset A \to \probset (\rr \times A)$
sends the pair $(r, p)$ of a reward and a probability distribution and yields
the probability distribution $\delta_r p$.
Let's see how this lets us iterate the dynamics of a $\probset(\rr\times
-)$-system $\Sys{S}$. We have $\update{S} : \State{S} \times \In{S} \to
\probset(\rr \times \State{S})$, giving us a probabilities
$\update{S}(s, i)(r, s')$ of transitioning from state $s$ on action $i$ into
state $s'$ and receiving reward $r$. To iterate this, we form the composite
$$\probset(\rr \times \State{S} ) \times \In{S}\xto{\sigma \circ (\id \times \eta)} 
\probset(\rr \times \State{S} \times \In{S}) \xto{\update{S}^{\probset(\rr
    \times -)}} \probset(\rr \times \State{S})$$
which sends a pair $(p, i)$ of a prior probability distribution on states and an
an action to the distribution $(r, s) \mapsto \sum_{s' \in \State{S}}p(s')
\update{S}(s', i)(r, s)$ which gives the probability of receiving the reward $r$
and transitioning into the state $s$ conditioned upon the prior $p$. To iterate,
we can continually apply this map to many inputs; let's just do $i$ and $j$. Then we end up
with the distribution
\[
(r, s) \mapsto \sum_{s'' \in \State{S}}\sum_{s' \in \State{S}}\sum_{r'' + r' = r}
p(s)\cdot\update{S}(s'', i)(r'', s')\cdot \update{S}(s', j)(r', s)
\]
which is the probability that we transition to $s$ in two steps and receive a
cumulative reward of $r$.
\end{example}


\iffalse
\paragraph{Popping rewards out of a monad}

Instead of having a chance of transitioning and getting a reward, we might think
that the agent has an expected reward for each action. Since this is an
expectation, it is independent of the actual resulting state.

If we had a likelyhood $u \in \probset(\rr \times \State{S})$ of transitioning
to a state and getting a reward, then we could calculate our expected reward by
taking the expectated value of the marginalization of $u$ to $\rr$.To find the
likelyhood of transitioning to the next state, independent of reward, we just
marginalize $u$ to $\State{S}$. This gives
us a map
\[
\rho : \probset(\rr \times A) \to \rr \times \probset A
\]
defined as the composite 
\[
\rho = \probset(\rr \times A) \xto{(\probset \pi_1, \probset \pi_2)}
\probset \rr \times \probset A \xto{E \times \id} \rr \times \probset A.
\]
Here, the map $E : \probset \rr \to \rr$ is the \emph{expected value} map:
\[
E(p) \coloneqq \sum_{r \in \rr} p(r) \cdot r.
\]
We note that the sum on the right hand side is no longer a formal convex
combination but an actual convex combination in $\rr$.

We might say that $\rho$ lets us ``pop $\rr$ out of $\probset$''. Just as how
the map $\lambda : \rr \times \probset A \to \probset(\rr \times A)$ which
``put $\rr$ into $\probset$'' let us turn $\probset(\rr \times A)$ into a
commutative monad, $\rho$ will let us turn $\rr \times \probset A$ into a
commutative monad.

Before getting bogged down in calculations with expected values, let's take a
moment to understand the relation of the expected value $E : \probset \rr \to
\rr$ to the monad $\probset$. This is an instance of an \emph{algebra} of the
monad $\probset$.

\begin{definition}
  Let $M : \cat{C} \to \cat{C}$ be a monad. An \emph{algebra} for $M$ consists
  of an object $A$ of $\cat{C}$ and a map $\alpha : M A \to A$ satisfying the
  following laws:
  \begin{itemize}
  \item (Unit) $\alpha \circ \eta = \id_A$:
    \[
      \begin{tikzcd}
        A \ar[r, "\eta"] \ar[dr, equals] & M A \ar[d, "\alpha"] \\
        & A
      \end{tikzcd}
    \]
    \item (Associativity) $\alpha \circ M\alpha = \alpha \circ \mu$, where $\mu
      = \id^{M}_{MA} : M M A \to M A$:
      \[
        \begin{tikzcd}
          MM A \ar[d, "\mu"] \ar[r, "M\alpha"] & M A \ar[d, "\alpha"] \\
          M A \ar[r, "\alpha"'] & A
        \end{tikzcd}
      \]
  \end{itemize}

  A map of $M$-algebras $f : \alpha \to \beta$ is a map $f : A \to B$ such that
  $f \circ \alpha = \beta \circ M f$:
  \[
        \begin{tikzcd}
          M A \ar[d, "\alpha"] \ar[r, "Mf"] & M B \ar[d, "\beta"] \\
           A \ar[r, "f"'] & B 
        \end{tikzcd}
      \]
  We call the resulting category $\Cat{Alg}(M)$ the category of algebras of $M$.
\end{definition}

\begin{proposition}
  If $\cat{C}$ is a cartesian category and $M : \cat{C} \to \cat{C}$ is a monad,
  then $\Cat{Alg}(M)$ is a cartesian category with the product of $\alpha : MA
  \to A$ and $\beta : MB \to B$ given by
  \[
M(A \times B) \xto{(M \pi_1, M\pi_2)} MA \times M B \xto{\alpha \times \beta} A
\times B.
  \]
\end{proposition}
\begin{proof}
  We just need to show that the product described above has the correct
  universal property. If $a : X \to A$ and $b : X \to B$ are algebra maps from
  $\chi : MX\to X$, then we just need to show that $(a, b) : X \to A \times B$
  is an algebra map as well. That is, we need to show that the following square commutes:
  \[
        \begin{tikzcd}
          M X \ar[d, "\chi"] \ar[r, "{M(a, b)}"] & M (A \times B) \ar[d, "{(M\pi_1, M\pi_2)\then (\alpha
          \times \beta)} "] \\
           X \ar[r, "{(a, b)}"'] & A \times B 
        \end{tikzcd}
  \]
  This follows quickly from the functoriality of $M$ and the fact that $a$ and
  $b$ are algebra maps.
  \begin{align*}
    M(a, b) \then (M \pi_1, M\pi_2) \then (\alpha \times \beta) &= (M((a, b) \then \pi_1), M((a, b)\then \pi_2)) \then (\alpha \times \beta) \\
                                                                &= (M a, M b) \then (\alpha \times \beta) \\
                                                                &= (M a \then \alpha, M b \then \beta) \\
                                                                &= (\chi \then a, \chi \then b) \\
    &= \chi \then (a, b).
 \end{align*}
\end{proof}

\begin{proposition}
  The expected value $E : \probset \rr \to \rr$ defined by
  $$E(p) = \sum_{r \in \rr} p(r) \cdot r$$
  makes $\rr$ into an algebra for
  the probability monad.

  Moreover, $(\rr, +, 0)$ is a commutative monoid in the category of algebras of $\probset$.
\end{proposition}
\begin{proof}
  We check the two laws:
  \begin{itemize}
    \item (Unit) This says that the expected value of a Dirac delta distribution
      centered at $x$ is $x$. \[
E(\delta_x) = \sum_{r \in \rr} \delta_x(r) \cdot r = x.
\]
\item (Associativity) This says that expectation is convex linear. that is, if
  we have a convex linear combination $\sum_i \lambda_i p_i \in
  \probset\probset \rr$ of probability distributions on $\rr$, then
  \[
E\left( r \mapsto \sum_i \lambda_i p_i(r) \right) = \sum_{r \in \rr} \sum_i \lambda_i p_i(r)
= \sum_i \lambda_i \sum_{r \in \rr}  p_i(r) = E\left( \sum_i \lambda_i E(p_i) \right).
  \]
  \end{itemize}

  To check that $(\rr, +, 0)$ is a commutative monoid in the category of
  algebras for $\probset$, we just need to check that $+$ is an algebra map.
  This comes down to showing that $+$ is convex linear, which it quite clearly is.
\end{proof}

\fi



\section{Changing the flavor of non-determinism: Monad maps}\label{sec.monad_map}

In the same way that $0$ is a number, determinstic systems are 
non-deterministic systems, just with a trivial sort of non-determinism. Deterministic systems are $M$-systems for the
\emph{identity monad} $\id(X) = X$. No matter what kind of non-determinism we
are considering, we can always consider a deterministic system as a
non-deterministic system, because we can take the $\update{}: \State{} \times
\In{} \to \State{}$ and post compose by $\eta : \State{} \to M\State{}$. This
operation of turning a deterministic system into an $M$-system has a few nice
properties; for example, if we iterate the system and then turn it into an
$M$-system, we get the same result as if we had iterated it as an $M$-system.

In general, if we have a commutative monad morphism $M \to N$, then we can turn
$M$-systems into $N$-systems.

\begin{definition}\label{def.com_monad_map}
A commutative monad map $\phi : M \to N$ is a natural transformation for which
the following diagrams commute:
\begin{itemize}
\item
  \begin{equation}\label{eqn.com_monad_map_unit}
    \begin{tikzcd}
    A \ar[r, "\eta^M"] \ar[dr, "\eta^N"'] & M A \ar[d, "\phi"] \\
    & N A
    \end{tikzcd}
  \end{equation}
\item
  \begin{equation}\label{eqn.com_monad_map_mult}
    \begin{tikzcd}
    M^2 A \ar[r, "M\phi \then \phi"] \ar[d, "\mu^M"'] & N^2 A \ar[d, "\mu^N"] \\
    M A \ar[r, "\phi"'] & NA
    \end{tikzcd}
  \end{equation}
\item
  \begin{equation}\label{eqn.com_monad_map_tensor}
    \begin{tikzcd}
    MA \times M B \ar[r, "\phi \times \phi"] \ar[d, "\sigma^M"'] & N A \times N B \ar[d, "\sigma^N"] \\
    M (A \times B) \ar[r, "\phi"'] & N(A \times B)
    \end{tikzcd}
  \end{equation}
\end{itemize}
\end{definition}



\begin{proposition}
  There is a unique commutative monad map $\id \to M$, and it is given by
  $\eta^M$. \end{proposition}
\begin{proof}
Let $\phi$ be such a map. Then condition \cref{eqn.com_monad_map_unit} says
precisely that $\phi = \eta^M$. So it just remains to check that $\eta$ is a commutative monad map.
  Now, \cref{eqn.com_monad_map_unit} commutes trivially, and
  \cref{eqn.com_monad_map_mult} is in this case one of the diagrams defining $M$
  from \cref{eqn.monad_laws}. Finally, \cref{eqn.com_monad_map_tensor} is in
  this case \cref{eqn.com_monad_monad_unit}.
\end{proof}

We can then turn any deterministic system $\Sys{S}$ into an $M$-system by
defining its new update to be $\eta^M \circ \update{S}$. For possibilistic
systems, this says that only the state that $\Sys{S}$ actually transitions into
is possible. For stochastic systems, this says that the probability that the
system transitions into the state it actually transitions into is $1$.

Intuitively, stochastic non-determinism is a refinement of possibilistic
non-determinism: it not only tells us what is possible, but how likely it is. We
can package this intuition into a commutative monad morphism $\phi : \probset
\to \powset$.
\begin{proposition}
  There is a commutative monad morphism $\phi : \probset \to \powset$ given by
  sending a probability distribution to the set of elements with non-zero probability:
  \[
\phi(p) = \{a \in A \mid p(a) \neq 0\}.
  \]
\end{proposition}
\begin{proof}
  We check that this satisfies the laws.
  \begin{itemize}
    \item (\cref{eqn.com_monad_map_unit}) The only element which $\delta_a$
      assigns a non-zero probability is $a$.
    \item (\cref{eqn.com_monad_map_mult}) Given a formal convex combination
      $\sum_i \lambda_i p_i$ of probability distributions $p_i \in \probset A$,
      we see that
      \[
\phi\mu^{\probset}\left( \sum_{i}\lambda_i p_i \right) = \{a \in A \mid \sum_i
\lambda_i p_i(a) \neq 0\},
      \]
      while
      \[
\probset\phi\left( \sum_i \lambda_i p_i \right) = \sum_{i} \lambda_i \{a \in A
\mid p_i(a) \neq 0\}
\]
and so taking $\phi$ of that yields
\[
\{\{a \in A \mid p_i(a) \neq 0\} \mid \lambda_i \neq 0\}
\]
so, finally
\[
\mu^{\powset}\left( \phi \probset \phi\left( \sum_i \lambda_i p_i \right) \right)
= \bigcup_{\lambda_i \neq 0} \{a \in A \mid p_i(a) \neq 0\}.
\]
Both paths around the square are equal since all of the $\lambda_i$ and $p_i(a)$ are positive.
\item (\cref{eqn.com_monad_map_tensor}) Let $p$ be a probability distribution on
  $A$ and $q$ a probability distribution on $B$. Then
  \[
\phi(\sigma(p, q)) = \{(a, b) \mid p(a)q(b) \neq 0\}
\]
while
\[
\sigma(\phi(p), \phi(q)) = \{(a, b) \mid p(a) \neq 0\, q(b) \neq 0\}.
\]
These are equal since $p(a)q(b) \neq 0$ if and only if both $p(a)$ and $q(b)$
are not $0$.
  \end{itemize}
\end{proof}

This lets us turn a stochastic system into a possibilistic system, saying that a
transition is possible if it has non-zero probability.

\begin{exercise}
Show that $\probset \eta^{\rr} : \probset A \to \probset(\rr \times A)$ is a
commutative monad morphism. That is, show that the following diagrams commute:
\begin{enumerate}
\item
  \begin{equation}
    \begin{tikzcd}
    A \ar[r, "\eta^{\probset}"] \ar[dr, "\eta^{\probset(\rr \times -)}"'] & \probset A \ar[d, "\probset(\eta^{\rr})"] \\
    & \probset(\rr \times A) 
    \end{tikzcd}
  \end{equation}
\item
  \begin{equation}
    \begin{tikzcd}[column sep=large]
    \probset^2 A \ar[r, "\probset\probset\eta^{\rr} \then \probset \eta^{\rr}"] \ar[d, "\mu^{\probset}"'] & \probset(\rr \times \probset(\rr \times A))\ar[d, "\mu^{\probset(\rr \times -)}"] \\
    \probset A \ar[r, "\probset \eta^{\rr}"'] & \probset(\rr \times A)
    \end{tikzcd}
  \end{equation}
\item
  \begin{equation}
    \begin{tikzcd}[column sep=large]
    \probset A \times \probset B \ar[r, "\probset \eta^{\rr} \times \probset\eta^{\rr}"] \ar[d, "\sigma^{\probset}"'] & \probset(\rr \times A) \times \probset(\rr \times B) \ar[d, "\sigma^{\probset(\rr \times -)}"] \\
    \probset (A \times B) \ar[r, "\probset \eta^{\rr}"'] & \probset( \rr \times A \times B)
    \end{tikzcd}
  \end{equation}
\end{enumerate}
This shows that we can always consider a stochastic system as a stochastic
system with rewards by assigning every transition the reward 0.
\end{exercise}

The reason we need all the laws for the monad morphism and not just an arbitrary family of
maps $\phi : MA \to N A$ is that with these laws, we get functors $\Cat{Kl}(M)
\to \Cat{Kl}(N)$ which tell us that iterating and then changing our
non-determinism is the same as changing our non-determinism and then iterating. We begin with a useful lemma.
\begin{lemma}\label{lem.com_monad_map_lift}
  In the definition of a commutative monad map $\phi : M \to N$, the
  commutativity of diagram
  \cref{eqn.com_monad_map_mult} can be replaced by the commutativity of the
  following diagram for any $f : A \to M B$:
  \begin{equation}\label{eqn.com_monad_map_lift}
    \begin{tikzcd}
    M A \ar[r, "\phi"] \ar[d, "f^{M}"'] & N A \ar[d, "(f \then \phi)^N"] \\
    M B \ar[r, "\phi"'] & NB
    \end{tikzcd}
  \end{equation}
  That is,
  \[
f^M \then \phi = \phi \then (f \then \phi)^N.
  \]
  In do notation, this reads
\[
  \phi\left(  \unalignedDo{
   $x \from m$,
   $f(x)$,
  }\right) = \unalignedDo{
    $x \from \phi(m)$,
    $\phi(f(x))$
  }
\]
\end{lemma}
\begin{proof}
Before we begin, we note that, by the
  naturality of $\phi$, $M\phi \then \phi = \phi \then N\phi$:
  \[
    \begin{tikzcd}
    M^2 A \ar[r, "\phi_{MA}"] \ar[d, "M\phi_A"'] & NM A \ar[d, "N\phi_A"] \\
    MN A \ar[r, "\phi_{NA}"'] & N^2 A
    \end{tikzcd}
  \]
  That is, we can take the top of \cref{eqn.com_monad_map_mult} to be $\phi \then
  N\phi$ rather than $M\phi \then \phi$.

  We recall that $f^M = Mf \then \mu^M$, and similarly $(f \then \phi)^N = N(f
  \then \phi) \then \mu^N$. So we may rewrite \cref{eqn.com_monad_map_lift} as
  the solid outer diagram in 
  \begin{equation}\label{eqn.com_monad_map_lift_helper}
\begin{tikzcd}
M A \arrow[r, "\phi"] \arrow[d, "Mf"']                          & NA \arrow[d, "Nf \then N\phi)"] \\
M^2 B \arrow[d, "\mu^M"'] \arrow[r, "\phi \then N\phi", dashed] & N^2 B \arrow[d, "\mu^N"]        \\
MB \arrow[r, "\phi"']                                           & N B                            
\end{tikzcd}
\end{equation}
Now we are ready to prove our lemma. We note that the top square in this diagram
always commutes by the naturality of $\phi$. \cref{eqn.com_monad_map_mult} is the lower
square in this diagram; so, if it commutes, then the outer square (which is
\cref{eqn.com_monad_map_lift}) commutes. On the other hand, if
\cref{eqn.com_monad_map_lift} commmutes for all $f : A \to M B$, we may take $f
= \id : M A \to M A$ to find that the outer square of
\cref{eqn.com_monad_map_lift_helper} becomes just \cref{eqn.com_monad_map_mult}.
\end{proof}


\begin{proposition}
  Let $\phi : M \to N$ be a commutative monad morhpisms. Then there is a
  strict symmetric monoidal functor
  $$\phi_{\ast} : \Cat{Kl}(M) \to \Cat{Kl}(N)$$
  acting as the identity on objects and sending the Kleisli map $f : A \to MB$
  to the composite \[\phi_{\ast}f \coloneqq A \xto{f} M B \xto{\phi} N B.\]
\end{proposition}
\begin{proof}
  We will check that this is a functor; that it is strictly symmetric monoidal
  follows from this and from the fact that it acts as the identity on objects. 
  The identity $\eta^M : A \to M A$ in $\Cat{Kl}(M)$ gets sent to
  $\phi_{\ast}\eta^M = \eta^M \then \phi$. This equals $\eta^N : A \to NA$ by \cref{eqn.com_monad_map_unit}.

  Given $f : A \to MB$ and $g : B \to MC$, their composite is $f \then g^M : A
  \to M C$, so that
  \begin{align*}
    \phi_{\ast}(f \then g^M) &\coloneqq f \then g^M \then \phi \\
                             &= f \then \phi \then (g \then \phi)^N &\mbox{by \cref{lem.com_monad_map_lift}}\\
    &= (\phi_{\ast} f)(\phi_{\ast} g)^N.
  \end{align*} 
\end{proof}

We can also check that $\phi_{\ast}$ is a functor using our string diagram
notation for monads. In that notation, $\phi : M \to N$ is written as
\[
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (0, 0) {$\phi$};
		\node [style=none] (1) at (-1, 0) {};
		\node [style=none] (2) at (1, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red] (1.center) to (0);
		\draw [style=object orange] (0) to (2.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
and would satisfy the laws:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (0, 0) {$\phi$};
		\node [style=function red] (1) at (-1, 0) {};
		\node [style=none] (2) at (1, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red] (1) to (0);
		\draw [style=object orange] (0) to (2.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function orange] (1) at (-1, 0) {};
		\node [style=none] (2) at (1, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object orange] (1) to (2.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (0, 0) {$\phi$};
		\node [style=none] (2) at (1, 0) {};
		\node [style=none] (3) at (-1, 0) {};
		\node [style=none] (4) at (-2, 0.5) {};
		\node [style=none] (6) at (-2, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object orange] (0) to (2.center);
		\draw [style=object red, bend left, looseness=0.75] (4.center) to (3.center);
		\draw [style=object red, bend right, looseness=0.75] (6.center) to (3.center);
		\draw [style=object red] (3.center) to (0);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (-1, 0.5) {$\phi$};
		\node [style=none] (3) at (-2, 0.5) {};
		\node [style=none] (4) at (0, 0) {};
		\node [style=none] (5) at (-1, 0.5) {};
		\node [style=none] (6) at (1, 0) {};
		\node [style=none] (7) at (-1, -0.5) {};
		\node [style=function clear] (8) at (-1, -0.5) {$\phi$};
		\node [style=none] (9) at (-2, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red] (3.center) to (0);
		\draw [style=object orange] (4.center) to (6.center);
		\draw [style=object orange, bend left, looseness=0.75] (5.center) to (4.center);
		\draw [style=object orange, bend right, looseness=0.75] (7.center) to (4.center);
		\draw [style=object red] (9.center) to (8);
	\end{pgfonlayer}
\end{tikzpicture}
\]
(As before, these diagrams are not really equipped to describe the commutativity of monads, and so we are only using the laws concerning the unit and multiplication.) The action of $\phi_{\ast}$ on a Kleisli map $f : X \to MY$ is then written as
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (0, 0) {$f$};
		\node [style=none] (1) at (-1, 0) {};
		\node [style=none] (2) at (2, 0) {};
		\node [style=function clear] (3) at (1, -0.5) {$\phi$};
		\node [style=none] (4) at (2, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (0) to (3);
		\draw [style=object orange] (3) to (4.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
We can check that $\phi_{\ast}$ is functorial quickly and diagrammatically:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (1) at (-1, 0) {};
		\node [style=none] (2) at (2, 0) {};
		\node [style=function clear] (3) at (1, -0.5) {$\phi$};
		\node [style=function red] (4) at (0, -0.5) {};
		\node [style=none] (5) at (2, -0.5) {};
		\node [style=none] (6) at (2, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (2.center);
		\draw [style=object red] (4) to (3);
		\draw [style=object orange] (3) to (6.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (1) at (-1, 0) {};
		\node [style=none] (2) at (1, 0) {};
		\node [style=function orange] (4) at (0, -0.5) {};
		\node [style=none] (6) at (1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (2.center);
		\draw [style=object orange] (4) to (6.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (-1, 0) {$f$};
		\node [style=none] (1) at (-2, 0) {};
		\node [style=none] (2) at (0, 0) {};
		\node [style=none] (3) at (1.75, -1.5) {};
		\node [style=function clear] (4) at (1, 0) {$g$};
		\node [style=none] (5) at (0, 0) {};
		\node [style=none] (6) at (4.5, 0) {};
		\node [style=none] (8) at (2.5, -1) {};
		\node [style=none] (9) at (1.75, -0.5) {};
		\node [style=function clear] (10) at (3.5, -1) {$\phi$};
		\node [style=none] (11) at (4.5, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (0) to (3.center);
		\draw [style=object] (5.center) to (4);
		\draw [style=object] (4) to (6.center);
		\draw [style=object red] (8.center) to (10);
		\draw [style=object red, bend left, looseness=0.75] (9.center) to (8.center);
		\draw [style=object red, bend right, looseness=0.75] (3.center) to (8.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (4) to (9.center);
		\draw [style=object orange] (10) to (11.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (-1, 0) {$f$};
		\node [style=none] (1) at (-2, 0) {};
		\node [style=none] (2) at (0, 0) {};
		\node [style=function clear] (3) at (0, -0.5) {$\phi$};
		\node [style=function clear] (4) at (1, 0) {$g$};
		\node [style=none] (5) at (0, 0) {};
		\node [style=none] (6) at (3.5, 0) {};
		\node [style=none] (8) at (2.5, -1) {};
		\node [style=function clear] (9) at (1.75, -0.5) {$\phi$};
		\node [style=none] (11) at (3.5, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object red, in=180, out=-60] (0) to (3);
		\draw [style=object] (5.center) to (4);
		\draw [style=object] (4) to (6.center);
		\draw [style=object orange, bend left, looseness=0.75] (9) to (8.center);
		\draw [style=object orange, in=-135, out=0, looseness=1.25] (3) to (8.center);
		\draw [style=object red, in=180, out=-60] (4) to (9);
		\draw [style=object orange] (8.center) to (11.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]



\section[Wiring together non-deterministic systems]{Wiring together non-deterministic systems: the generalized lens construction}\label{sec.wiring_together_non_det}

Consider a stochastic source process 
  \[
\begin{tikzpicture}[oriented WD, every fit/.style={inner xsep=\bbx, inner ysep=\bby}, bbx = 1cm, bby =.5cm, bb min width=1cm, bb port length=4pt, bb port sep=1, baseline=(X.center)]
	\node[bb={0}{1}, fill=blue!10] (X) {$\Sys{Source}$};
	\draw[label] 
		node [right=2pt of X_out1] {}
		;
\end{tikzpicture}
  \]
We can imagine, as Claude Shannon did, that this source is an interlocutor
communicating over a wire. Suppose we have another interlocutor who will read
the signal generated by our source and generate their own signal in repsonse:
  \[
\begin{tikzpicture}[oriented WD, every fit/.style={inner xsep=\bbx, inner ysep=\bby}, bbx = 1cm, bby =.5cm, bb min width=1cm, bb port length=4pt, bb port sep=1, baseline=(X.center)]
	\node[bb={1}{1}, fill=blue!10] (X) {$\Sys{Transformer}$};
	\draw[label] 
		node [right=2pt of X_out1] {}
		;
\end{tikzpicture}
  \]
Having these two models, we can form a new stochastic source by considering them
together:
\[
\begin{tikzpicture}[oriented WD, every fit/.style={inner xsep=\bbx, inner ysep=\bby}, bbx = 1cm, bby =.5cm, bb min width=1cm, bb port length=0pt, bb port sep=1, baseline=(X.center)]
	\node[bb={0}{1}, fill=blue!10] (X) {$\Sys{Source}$};
  \node[draw=dgreen,circle, right = of X] (n) {$\rho$};
	\node[bb={1}{1}, fill=blue!10, right = of n] (Y) {$\Sys{Transformer}$};
  \node[bb={0}{1}, fit={(X) (Y)}] (Z) {};

  \draw (X_out1) -- (n) -- (Y_in1);
  \draw (Y_out1) -- (Z_out1);
\end{tikzpicture}
\]
We imagine that the $\Sys{Transformer}$ listens to the signal generated by the
$\Sys{Source}$, but with noise $\rho$ on the wire. This wiring diagram
\[
\begin{tikzpicture}[oriented WD, every fit/.style={inner xsep=\bbx, inner ysep=\bby}, bbx = 1cm, bby =.5cm, bb min width=1cm, bb port length=0pt, bb port sep=1, baseline=(X.center)]
	\node[bb={0}{1}, fill=blue!10, dashed] (X) {$\phantom{\Sys{Source}}$};
  \node[draw=dgreen,circle, right = of X] (n) {$\rho$};
	\node[bb={1}{1}, fill=blue!10, right = of n, dashed] (Y) {$\phantom{\Sys{Transformer}}$};
  \node[bb={0}{1}, fit={(X) (Y)}] (Z) {};


  \draw (X_out1) -- (n) -- (Y_in1);
  \draw (Y_out1) -- (Z_out1);
  

	\draw[label] 
		node at ($(X_out1) + (5pt, 5pt)$) {$A$}
		node at ($(Y_out1) + (5pt, 5pt)$) {$C$}
		node at ($(Y_in1) + (-5pt, 5pt)$) {$B$}
		;
\end{tikzpicture}
\]
can be described as a \emph{monadic lens} $\lens{f^{\sharp}}{f} : \lens{B}{A
  \times C} \fromto \lens{\ord{1}}{C}$:
\begin{itemize}
\item $f : A \times C \to C$ is the projection $\pi_2$.
\item $f^{\sharp}: A \times C \times \ord{1} \to D B$ is $\rho \circ \pi_1$ where $\rho : A \to
  D B$ is the stochastic function describing the noise on the wire.
\end{itemize}
This new notion of monadic lens which lets us wire together non-deterministic
systems will be the focus of this section.

In \cref{sec.wiring_discrete_systems}, we saw how to wire together systems
deterministically and with functions from an algebraic theory on the wire. This
worked because wiring diagrams could be interpreted as lenses, and deterministic
and differential systems were also lenses; then we could just compose them.

But non-deterministic systems are not lenses in a cartesian category; they have
that monad sitting over the states in the codomain of $\update{}$:
\[
\update{S} : \State{S} \times \In{S} \to M \State{S}.
\]
It may appear that we could consider this as a map in the Kleisli category, and
just take lenses in the Kleisli category. But in the Kleisli category, the
operation $\times$ is rarely a cartesian product, and we can only describe
lenses in cartesian categories. The reason we can only describe lenses in
cartesian categories is because in the formula for the passback of a composite
of lenses, we use a variable twice; that is, we use the diagonal map $\Delta : A^+ \to
A^+ \times A^+$, a feature of cartesian categories. 


We will need a new perspective on lenses and
lens composition which suggests how to change the passback of the lenses. It is
worth noting that we only need to duplicate in the passforward direction; we
should be free to change the passback direction.

In this section, we will give a new perspective on the category of lenses using
the \emph{Grothendieck construction}. This perspective constructs the category
of lenses out of an \emph{indexed category} $\smctx{-} : \cat{C}\op \to
\Cat{Cat}$ of objects of the cartesian category $\cat{C}$ \emph{in context}.
This construction works for \emph{any} indxed category $\cat{A} : \cat{C}\op \to
\Cat{Cat}$, which lets us define a notion of $\cat{A}$-lenses out of any indexed
category. By choosing an appropriate indexed category, we will arrive at the
notion of $M$-lenses for a commutative monad $M$; this will give us the wiring
diagram calculus for non-deterministic systems that we wanted.

First, we introduce the abstract categorical notions of \emph{indexed category}
and the \emph{Grothendieck construction}.




\subsection{Indexed categories and the Grothendieck construction}\label{sec.indexed_categories}

An indexed category $\cat{A} : \cat{C}\op \to \Cat{Cat}$ is a family of
categories $\cat{A}(C)$ that varies functorially with an object $C \in \cat{C}$
of the \emph{base category} $\cat{C}$ (see \cref{def.indexed_cat} for the full
definition). We will intepret the base category $\cat{C}$ as the category of
passforward maps, and the categories $\cat{A}(C^+)$ as the categories of
passback maps that take $C^+$ as an extra argument.
%%
%% :CUSTOM-ID:cite-this.pseudo_functors
%%

\begin{definition}
  A \emph{strict indexed category} $\cat{A} : \cat{C}\op \to \Cat{Cat}$ is a
  contravariant functor\footnote{A pseudo-functor is like a functor,
    but it only satisfies the functoriality conditions up to isomorphism, and
    these isomorphisms must satisfy some laws that make them ``cohere''. The
    indexed categories we will see in \cref{chapter.1,chapter.2,chapter.3}
    will all be actual functors, however.}. We call the category $\cat{C}$ the
  \emph{base} of the indexed category $\cat{A}$. Explicitly, an indexed
  category $\cat{A}$ has:
  \begin{itemize}
  \item A base category $\cat{C}$.
  \item For every object $C \in \cat{C}$ of the base, a category $\cat{A}(C)$.
  \item For every map $f : C \to C'$ in the base, a \emph{pullback} functor
    $f^{\ast} : \cat{A}(C') \to \cat{A}(C)$, which we think of as ``reindexing''
    the objects of $\cat{A}(C')$ so that they live over $\cat{A}(C)$.
  \item Reindexing is functorial: $(f \then g)^{\ast} = g^{\ast} \then f^{\ast}$
    and $\id^{\ast} = \id$.
  \end{itemize}
\end{definition}

\begin{remark}\label{rmk.co(Pseudo-functoriality)}
    We have given the definition of a \emph{strict} indexed category. A general
    indexed category is a \emph{pseudo-}functor $\cat{A} : \cat{C}\op \to
    \Cat{Cat}$, which is like a functor but functoriality only holds up to
    coherent isomorphism. As in the case of monoidal categories, the coherences
    in the isomorphisms are often just bookkeeping trivialities. 

However, the
    theory of strict indexed categories is noticeably easier, and most of our
    examples will be strict. Since we will mostly be using strict indexed
    categories, we will often refer to them simply as ``indexed categories''.
\end{remark}

Indexed categories are quite common throughout mathematics. We will construct a
particular example for our own purposes in \cref{sec.context_indexed_cat}, and
more throughout the book.

\begin{example}\label{ex.indexed_cat_of_dependent_sets}
  Recall that a \emph{dependent set} is a function $X : A \to \smset$ from a set
  into the category of sets. We have an indexed category of dependent sets
  $$\smset^{(-)} : \smset\op \to \Cat{Cat}$$
  which is defined as follows:
  \begin{itemize}
    \item To each set $A$, we assign the category $\smset^A$ of sets indexed by
      $A$. The objects of $\smset^A$ are the sets $X : A \to \smset$ indexed by
      $A$, and a map $f : X \to Y$ is a family of maps $f_a : X_a \to Y_a$
      indexed by the elements $a \in A$. Composition is given componentwise: $(g
      \circ f)_a = g_a \circ f_a$.
    \item To every function $f : A' \to A$, we get a reindexing functor
$$f^{\ast} : \smset^A \to \smset^{A'}$$
   Given by precomposition: $X \mapsto X \circ f$. The indexed set $X \circ f :
   A' \to \smset$ is the set $X_{f(a')}$ on the index $a' \in A'$. The families
   of functions get reindexed the same way.
     \item Since our reindexing is just given by precomposition, it is clearly
       functorial.
  \end{itemize}
  We will return to this example in much greater detail in \cref{chapter.4}.
\end{example} 


If we have an family of sets $A : I \to \Cat{Set}$ indexed by a set $I$, we can
form the disjoint union $\sum_{i \in I} A_i$, together with the projection $\pi
: \sum_{i \in I} A_i \to I$ sending each $a \in A_i$ to $i$. The Grothendieck
construction is a generalization of this construction to indexed categories. Namely, we will take an indexed category $\cat{A}
: \cat{C} \to \Cat{Cat}$ and form a new category

$$\int^{C : \cat{C}} \cat{A}(C)$$
which we think of as a ``union'' off all the categories $\cat{A}(C)$. But this
``union'' will not be
disjoint since there will be morphisms from objects in $\cat{A}(C)$ to objects
in $\cat{A}(C')$. This is why we use the integral notation; we want to suggest
that the Grothendieck construction is a sort of sum.\footnote{The Grothendieck
  construction is an example of a \emph{lax colimit} in 2-category theory,
  another sense in which it is a `sort of sum'.}
\begin{definition}\label{def.grothendieck_construction}
  Let $\cat{A} : \cat{C}\op \to \Cat{Cat}$ be an indexed category. The
  \emph{Grothendieck construction} of $\cat{A}$
  $$\int^{C : \cat{C}} \cat{A}(C)$$
  is the category with:
  \begin{itemize}
    \item Objects pairs $\lens{A}{C}$ of objects $C \in \cat{C}$ and $A \in
      \cat{A}(C)$. We say that $A$ ``sits over'' $C$.
    \item Maps $\lens{f_{\flat}}{f} : \lens{A}{C} \rightrightarrows
      \lens{A'}{C'}$ pairs of $f : C \to C'$ in $\cat{C}$ and $f_{\flat} :
      A \to f^{\ast}A'$ in $\cat{A}(C)$.
    \item Given $\lens{f_{\flat}}{f} : \lens{A}{C} \rightrightarrows
      \lens{A'}{C'}$ and $\lens{g_{\flat}}{g} : \lens{A'}{C'} \rightrightarrows
      \lens{A''}{C''}$, their composite is given by
      $$\lens{g_{\flat}}{g} \circ \lens{f_{\flat}}{f} \coloneqq \lens{f^{\ast}g_{\flat}
      \circ f_{\flat}}{g \circ f}$$
    Written with the signatures, this looks like
    $$\lens{A \xto{f_{\flat}} f^{\ast}A' \xto{f^{\ast}g_{\flat}}
      f^{\ast}g^{\ast}A'' \xequals{\phantom{\gamma}} (g \circ f)^\ast A''}{C \xto{f} C' \xto{g} C''}$$
    \item The identity is given by $\lens{\id_A}{\id_C} : \lens{A}{C}
      \rightrightarrows \lens{A}{C}$
  \end{itemize}
\end{definition}

\begin{exercise}
  Check that \cref{def.grothendieck_construction} does indeed make $\int^{C :
    \cat{C}} \cat{A}(C)$ into a category. That is, check that composition as
  defined above is associative and unital.
\end{exercise}

\paragraph{Pure and cartesian maps.}\label{sec.pure_and_cartesian_maps}

A map in a Grothendieck construction is a pair $\lens{f_{\flat}}{f} :
\lens{A}{C} \tto \lens{A'}{C'}$ of maps $f : C \to C'$ and $f_{\flat}: A \to
f^{\ast}A'$. It is not too hard to see that a map is an isomorphism in a Grothendieck
construction if and only if both its constituent maps are isomorphisms in their
respective categories.

\begin{proposition}\label{prop.isomorphism_in_groth_construction}
Let $\cat{A} : \cat{C}\op \to \Cat{Cat}$ be an indexed category and let $\lens{f_{\flat}}{f} :
\lens{A}{C} \tto \lens{A'}{C'}$ be a map in its Grothendieck construction. Then
$\lens{f_{\flat}}{f}$ is an isomorphism if and only if $f$ is an isomorphism in
$\cat{C}$ and $f_{\flat}$ is an isomorphism in $\cat{A}(C)$.
\end{proposition}
\begin{proof}
First, let's show that if both $f$ and $f_{\flat}$ are isomorphisms, then
$\lens{f_{\flat}}{f}$ is an isomorphism. We then have $f\inv : C' \to C$ and
$f_{\flat}\inv : f^{\ast}A' \to A$. From $f_{\flat}\inv$, we can form
$(f\inv)^{\ast} (f_{\flat}\inv) : (f\inv)^{\ast}f^{\ast} A' \to
(f\inv)^{\ast}A$, which we can pre-compose with some of the coherences to have
the signature $A' \to (f\inv)^{\ast} A$:
$$A' \xequals{\,} (f \circ f\inv)^{\ast} A' \xequals{\,} 
(f\inv)^{\ast} f^{\ast} A' \xto{(f\inv)^{\ast} (f_{\flat}\inv)} (f\inv)^{\ast} A.$$
Now, consider the map $\lens{(f\inv)^{\ast}f_{\flat}\inv}{f\inv} : \lens{A'}{C'}
\tto \lens{A}{C}$. We'll show that this is an
inverse to $\lens{f_{\flat}}{f}$. Certainly, the bottom components will work
out; we just need to worry about the top. That is, we need to show that
$f^{\ast}((f\inv)^{\ast} f_{\flat}\inv) \circ f_{\flat} = \id$ and
$(f\inv)^{\ast}(f_{\flat}) \circ (f\inv)^{\ast}(f_{\flat}\inv) = \id$. Both of
these follow quickly by functoriality.

On the other hand, suppose that $\lens{f_{\flat}}{f}$ is an isomorphism with
inverse $\lens{g_{\flat}}{g}$. Then $gf = \id$ and $fg = \id$, so $f$ is an
isomorphism. We can focus on $f_{\flat}$. We know that $f^{\ast}g_{\flat} \circ
f_{\flat} = \id$ and $g^{\ast}f_{\flat} \circ g_{\flat} = \id$. Applying
$f^{\ast}$ to the second equation, we find that $f_{\flat} \circ
f^{\ast}g_{\flat} = \id$, so that $f_{\flat}$ is an isomorphism with inverse $f^{\ast}g_{\flat}$.
\end{proof}  

\begin{remark}
  \cref{prop.isomorphism_in_groth_construction} gives a general solution to
  \cref{ex.isomorphism_in_category_of_charts}, since the category of charts is a
  Grothendieck construction.
\end{remark}

This proposition suggests two interesting classes of maps in a Grothendieck
construction: the maps $\lens{f_{\flat}}{f}$ for which $f$ is an isomorphism, and
those for which $f_{\flat}$ is an isomorphism.
\begin{definition}\label{def.pure_and_cartesian}
Let $\cat{A} : \cat{C}\op \to \Cat{Cat}$ be an indexed category and let
$\lens{f_{\flat}}{f}$ be a map in its Grothendieck construction. We say that
$\lens{f_{\flat}}{f}$ is
\begin{itemize}
\item \emph{pure} if $f$ is an isomorphism, and
\item \emph{cartesian} if $f_{\flat}$ is an isomorphism.
\end{itemize}
\end{definition}

The pure maps correspond essentially to the maps in the categories $\cat{A}(C)$
at a given index $C$, while the cartesian maps correspond essentially to the
maps in $\cat{C}$.

\begin{remark}
  The name ``pure'' is non-standard. The usual name is ``vertical''. But we are
  about to talk about ``vertical'' maps in a technical sense when we come to
  double categories, so we've renamed the concept here to avoid confusion later.
\end{remark}

\begin{example}
  We have often seen systems that expose their entire state, like $\Sys{Time}$ 
  of \cref{ex.trajectory_as_behavior_discrete}. Considered as lenses, these are
  \emph{pure} in the sense that their $\expose{}$ function is an isomorphism.
\end{example}

\begin{exercise}\label{ex.2-of-3_for_pure_cartesian}
  Let $\lens{f_{\flat}}{f}$ and $\lens{g_{\flat}}{g}$ be composable maps in a Grothendieck construction,
  \begin{enumerate}
    \item Suppose that $\lens{g_{\flat}}{g}$ is cartesian.  Show that
      $\lens{f_{\flat}}{f}$ is cartesian if and only if their composite is
      cartesian. Is the same true for pure maps?
    \item Suppose that $\lens{f_{\flat}}{f}$ is pure. Show that
      $\lens{g_{\flat}}{g}$ is pure if and only if their composite is pure. Is
      the same true for cartesian maps?
  \end{enumerate}
\end{exercise}


%---- Section ----%
\subsection{Maps with context and lenses}\label{sec.context_indexed_cat}

In this section, we'll see the category $\Cat{Lens}_{\cat{C}}$ of lenses in a
cartesian category $\cat{C}$ can be described using
the Grothendieck construction. To do this, we need some other categories named
after their maps (rather than their objects): 
\emph{category of maps with context $C$} for some a given $C \in \cat{C}$. 

\begin{definition}
  Let $\cat{C}$ be a cartesian category and let $C \in \cat{C}$. The
  \emph{category $\smctx{C}$ of maps with context $C$}
  is the category defined by:
  \begin{itemize}
    \item Objects are the objects of $\cat{C}$.
    \item Maps $f : X \ctxto Y$ are maps $f : C \times X \to Y$.
    \item The composite $g \circ f$ of $f : X \ctxto Y$ and $g : Y \ctxto Z$ is
      the map
       $$(c, x) \mapsto g(c, f(c, x)) : C \times X \to Z.$$
       Diagrammatically, this is the composite:
       $$C \times X \xto{\Delta_C \times X} C \times C \times X \xto{C \times f}
       C \times Y \xto{g} Z.$$
    \item The identity $\id : X \ctxto X$ is the second projection $\pi_2 : C
      \times X \to X$.
  \end{itemize}
\end{definition}

We can prove that $\smctx{C}$ is a category using a similar string diagrams to
those we used in \cref{sec.monad_doctrine}. We have a functor $X \mapsto C
\times X : \cat{C} \to \cat{C}$ which we can draw as a blue string:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (1, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue] (0.center) to (1.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
If we represent $X \in \cat{C}$ by the string
\(
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (1, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (0.center) to (1.center);
	\end{pgfonlayer}
\end{tikzpicture}
\) then we represent $C \times X$ as
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (1, 0) {};
		\node [style=none] (2) at (1, -0.5) {};
		\node [style=none] (3) at (-1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (0.center) to (1.center);
		\draw [style=object blue] (3.center) to (2.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
We can therefore represent a morphism $f : C \times X \to Y$ in the context of
$C$ as a bead like this:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (0, 0) {$f$};
		\node [style=none] (1) at (1, 0) {};
		\node [style=none] (2) at (-1, 0) {};
		\node [style=none] (3) at (-1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (0) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
To compose maps in context, we need the diagonal map $\Delta_C \times X : C
\times X \to C \times C \times X$ and the second projection $\pi_2 : C \times X
\to X$. Since these maps are natural in $X$, we can draw them as
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (0, 0) {};
		\node [style=none] (1) at (1, 0.5) {};
		\node [style=none] (3) at (-1, 0) {};
		\node [style=none] (7) at (1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue] (0.center) to (3.center);
		\draw [style=object blue, bend right, looseness=0.75] (1.center) to (0.center);
		\draw [style=object blue, bend left, looseness=0.75] (7.center) to (0.center);
	\end{pgfonlayer}
\end{tikzpicture}
\quad\mbox{and}\quad
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function blue] (0) at (0, 0) {};
		\node [style=none] (3) at (-1, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue] (0) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
Then the composition in $\smctx{C}$ of maps in context $f : C \times X \to Y$ and $g : C \times
Y \to Z$ is drawn as:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (2.5, 0) {$g$};
		\node [style=none] (1) at (3.5, 0) {};
		\node [style=none] (2) at (1.5, 0) {};
		\node [style=none] (3) at (-0.25, -1.5) {};
		\node [style=function clear] (4) at (0.5, 0) {$f$};
		\node [style=none] (5) at (1.5, 0) {};
		\node [style=none] (6) at (-2, 0) {};
		\node [style=none] (8) at (-1, -1) {};
		\node [style=none] (9) at (-0.25, -0.5) {};
		\node [style=none] (10) at (-2, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (0) to (3.center);
		\draw [style=object] (5.center) to (4);
		\draw [style=object] (4) to (6.center);
		\draw [style=object blue] (8.center) to (10.center);
		\draw [style=object blue, bend right, looseness=0.75] (9.center) to (8.center);
		\draw [style=object blue, bend left, looseness=0.75] (3.center) to (8.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (4) to (9.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
and the second projection $\pi_2 : C \times X \to X$ is drawn
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (1) at (1, 0) {};
		\node [style=none] (2) at (-1, 0) {};
		\node [style=none] (3) at (-1, -0.5) {};
		\node [style=function blue] (4) at (0, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (2.center);
		\draw [style=object blue] (4) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
This is exactly dual to the story about Kleisli composition we saw in
\cref{sec.monad_doctrine}! To show that $\smctx{C}$ is a category, we need to
note that the following equations hold:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (0, 0.5) {};
		\node [style=none] (3) at (-2, 0) {};
		\node [style=function blue] (8) at (0, -0.5) {};
		\node [style=none] (12) at (1, 0.5) {};
		\node [style=none] (13) at (0, 0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue] (0.center) to (3.center);
		\draw [style=object blue, bend right, looseness=0.75] (1.center) to (0.center);
		\draw [style=object blue, bend left, looseness=0.75] (8) to (0.center);
		\draw [style=object blue] (12.center) to (13.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (0, -0.5) {};
		\node [style=none] (3) at (-2, 0) {};
		\node [style=function blue] (8) at (0, 0.5) {};
		\node [style=none] (12) at (1, -0.5) {};
		\node [style=none] (13) at (0, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue] (0.center) to (3.center);
		\draw [style=object blue, bend left, looseness=0.75] (1.center) to (0.center);
		\draw [style=object blue, bend right, looseness=0.75] (8) to (0.center);
		\draw [style=object blue] (12.center) to (13.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (0, 0.5) {};
		\node [style=none] (3) at (-2, 0) {};
		\node [style=none] (8) at (0, -0.5) {};
		\node [style=none] (9) at (1, 0) {};
		\node [style=none] (11) at (1, -1) {};
		\node [style=none] (12) at (1, 0.5) {};
		\node [style=none] (13) at (0, 0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue] (0.center) to (3.center);
		\draw [style=object blue, bend right, looseness=0.75] (1.center) to (0.center);
		\draw [style=object blue, bend right, looseness=0.75] (9.center) to (8.center);
		\draw [style=object blue, bend left, looseness=0.75] (11.center) to (8.center);
		\draw [style=object blue, bend left, looseness=0.75] (8.center) to (0.center);
		\draw [style=object blue] (12.center) to (13.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0) {};
		\node [style=none] (1) at (0, -0.5) {};
		\node [style=none] (3) at (-2, 0) {};
		\node [style=none] (8) at (0, 0.5) {};
		\node [style=none] (9) at (1, 0) {};
		\node [style=none] (11) at (1, 1) {};
		\node [style=none] (12) at (1, -0.5) {};
		\node [style=none] (13) at (0, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue] (0.center) to (3.center);
		\draw [style=object blue, bend left, looseness=0.75] (1.center) to (0.center);
		\draw [style=object blue, bend left, looseness=0.75] (9.center) to (8.center);
		\draw [style=object blue, bend right, looseness=0.75] (11.center) to (8.center);
		\draw [style=object blue, bend right, looseness=0.75] (8.center) to (0.center);
		\draw [style=object blue] (12.center) to (13.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
These say that
$$(\Delta_C \times X) \then (\pi_2 \times X)= \id_{C \times
  X} = (\Delta_C \times X) \then (C
\times \pi_2)$$
and
$$( \Delta_C \times X ) \then (C \times \Delta_C \times X) = ( \Delta_C \times
X) \then (\Delta_C\times X \times C).$$
These hold by some simple work in the cartesian category $\cat{C}$ (see \cref{ex.cartesian_comonad}).

With these laws in hand, we can prove associativity and identity of composition in $\smctx{C}$ by
appealing to the following diagrams:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (2.5, 0) {};
		\node [style=none] (1) at (3.5, 0) {};
		\node [style=none] (2) at (1.5, 0) {};
		\node [style=none] (3) at (-0.25, -1.5) {};
		\node [style=function clear] (4) at (0.5, 0) {$f$};
		\node [style=none] (5) at (1.5, 0) {};
		\node [style=none] (6) at (-2, 0) {};
		\node [style=none] (7) at (-1, -1) {};
		\node [style=none] (8) at (-0.25, -0.5) {};
		\node [style=none] (9) at (-2, -1) {};
		\node [style=function blue] (10) at (2.5, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0.center);
		\draw [style=object] (0.center) to (2.center);
		\draw [style=object] (5.center) to (4);
		\draw [style=object] (4) to (6.center);
		\draw [style=object blue] (7.center) to (9.center);
		\draw [style=object blue, bend right, looseness=0.75] (8.center) to (7.center);
		\draw [style=object blue, bend left, looseness=0.75] (3.center) to (7.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (4) to (8.center);
		\draw [style=object blue, in=0, out=180, looseness=1.25] (10) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (0, 0) {$f$};
		\node [style=none] (1) at (1, 0) {};
		\node [style=none] (2) at (-1, 0) {};
		\node [style=none] (3) at (-1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (0) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (2.5, 0) {$f$};
		\node [style=none] (1) at (3.5, 0) {};
		\node [style=none] (2) at (1.5, 0) {};
		\node [style=none] (3) at (-0.25, -1.5) {};
		\node [style=none] (4) at (0.5, 0) {};
		\node [style=none] (5) at (1.5, 0) {};
		\node [style=none] (6) at (-2, 0) {};
		\node [style=none] (8) at (-1, -1) {};
		\node [style=function blue] (9) at (-0.25, -0.5) {};
		\node [style=none] (10) at (-2, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (0) to (3.center);
		\draw [style=object] (5.center) to (4.center);
		\draw [style=object] (4.center) to (6.center);
		\draw [style=object blue] (8.center) to (10.center);
		\draw [style=object blue, bend right, looseness=0.75] (9) to (8.center);
		\draw [style=object blue, bend left, looseness=0.75] (3.center) to (8.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (2.5, 0) {$h$};
		\node [style=none] (1) at (3.5, 0) {};
		\node [style=none] (2) at (1.5, 0) {};
		\node [style=none] (3) at (-0.25, -1.5) {};
		\node [style=function clear] (4) at (0.5, 0) {$g$};
		\node [style=none] (5) at (1.5, 0) {};
		\node [style=none] (7) at (-1, -1) {};
		\node [style=none] (8) at (-0.25, -0.5) {};
		\node [style=none] (9) at (-2.5, -1) {};
		\node [style=function clear] (10) at (-1.5, 0) {$f$};
		\node [style=none] (12) at (-3.75, 0) {};
		\node [style=none] (13) at (-2.5, -0.5) {};
		\node [style=none] (14) at (-2.5, -1) {};
		\node [style=none] (15) at (-3.25, -0.75) {};
		\node [style=none] (16) at (-2.5, -0.5) {};
		\node [style=none] (17) at (-3.75, -0.75) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (0) to (3.center);
		\draw [style=object] (5.center) to (4);
		\draw [style=object blue] (7.center) to (9.center);
		\draw [style=object blue, bend right, looseness=0.75] (8.center) to (7.center);
		\draw [style=object blue, bend left, looseness=0.75] (3.center) to (7.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (4) to (8.center);
		\draw [style=object] (10) to (12.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (10) to (13.center);
		\draw [style=object] (4) to (10);
		\draw [style=object blue, bend right, looseness=0.75] (16.center) to (15.center);
		\draw [style=object blue, bend left, looseness=0.75] (14.center) to (15.center);
		\draw [style=object blue] (15.center) to (17.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (3.5, 0) {$h$};
		\node [style=none] (1) at (4.5, 0) {};
		\node [style=none] (2) at (2.5, 0) {};
		\node [style=none] (3) at (-1.5, -1.5) {};
		\node [style=function clear] (4) at (1.5, 0) {$g$};
		\node [style=none] (5) at (2.5, 0) {};
		\node [style=none] (8) at (-1.5, -1) {};
		\node [style=none] (9) at (-1.5, -1) {};
		\node [style=function clear] (10) at (-0.5, 0) {$f$};
		\node [style=none] (12) at (-3.75, 0) {};
		\node [style=none] (13) at (-1.5, -0.5) {};
		\node [style=none] (14) at (-1.5, -1) {};
		\node [style=none] (15) at (-2.25, -0.75) {};
		\node [style=none] (16) at (-1.5, -0.5) {};
		\node [style=none] (17) at (-3, -1) {};
		\node [style=none] (18) at (-3.75, -1) {};
		\node [style=none] (19) at (-1.5, -1.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (0) to (3.center);
		\draw [style=object] (5.center) to (4);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (4) to (8.center);
		\draw [style=object] (10) to (12.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (10) to (13.center);
		\draw [style=object] (4) to (10);
		\draw [style=object blue, bend right, looseness=0.75] (16.center) to (15.center);
		\draw [style=object blue, bend left, looseness=0.75] (14.center) to (15.center);
		\draw [style=object blue, in=45, out=180] (15.center) to (17.center);
		\draw [style=object blue] (17.center) to (18.center);
		\draw [style=object blue, bend left, looseness=0.75] (19.center) to (17.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]

\begin{exercise}\label{ex.cartesian_comonad}
  Show that the following composites are equal in any cartesian category:
  \begin{enumerate}
    \item 
$$(\Delta_C \times X) \then (\pi_2 \times X) = (\Delta_C \times X) \then (C
\times \pi_2)$$
These are both maps $C \times X \to C \times C \times C \times X$.
\item $$( \Delta_C \times X ) \then (C \times \Delta_C \times X) = \id_{C \times
  X} =  ( \Delta_C \times
X) \then (\Delta_C\times X \times C).$$
These are all maps $C \times X \to C \times X$.
  \end{enumerate}
\end{exercise}

\begin{exercise}\label{ex.maps_with_no_context}
Show that $\smctx{\ord{1}}$ is equivalent to the underlying cartesian category
$\cat{C}$. In other words, maps in the context $\ord{1}$ have ``no context''.
\end{exercise}

Together, we can arrange the categories of maps with context into
an indexed category.
\begin{definition}
  The \emph{indexed category of maps with context}
  $$\smctx{-} : \cat{C}\op \to \Cat{Cat}$$
  is defined by:
  \begin{itemize}
    \item For $C \in \cat{C}$, we have the category $\smctx{C}$ of maps with
      context $C$.
    \item For a map $r : C' \to C$, we get a reindexing functor
      $$r^{\ast} : \smctx{C} \to \smctx{C'}$$
      given by sending each object to itself, but each morphism $f : C \times X
      \to Y$ in $\smctx{C}$ to the map $r^{\ast}f \coloneqq f \circ (r \times X)$:
      $$C' \times X \xto{r \times X} C \times X \xto{f} Y.$$
      On elements,
      $$r^{\ast}f(c', x) \coloneqq f(r(c'), x).$$
  \end{itemize}
  We note that this is evidently functorial.
\end{definition}

To see that to every $r : C' \to C$ we get a functor $r^{\ast} : \smctx{C} \to
\smctx{C'}$, we can use string diagrams. We can draw $r$ as
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (0, 0) {$r$};
		\node [style=none] (1) at (-1, 0) {};
		\node [style=none] (2) at (1, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=new edge style 0] (1.center) to (0);
		\draw [style=object blue, in=180, out=0, looseness=0.75] (0) to (2.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
so that the action of $r^{\ast}$ is given by 
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (1, 0) {$f$};
		\node [style=none] (1) at (2, 0) {};
		\node [style=none] (2) at (-1, 0) {};
		\node [style=function clear] (3) at (0, -0.5) {$r$};
		\node [style=none] (4) at (-1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (0) to (3);
		\draw [style=new edge style 0] (3) to (4.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
If we note that $r$ satisfies the following laws:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (0, 0) {$r$};
		\node [style=function blue] (1) at (1, 0) {};
		\node [style=none] (2) at (-1, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue] (1) to (0);
		\draw [style=new edge style 0] (0) to (2.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=new style 0] (1) at (1, 0) {};
		\node [style=none] (2) at (-1, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=new edge style 0] (1) to (2.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (-1, 0) {$r$};
		\node [style=none] (2) at (-2, 0) {};
		\node [style=none] (3) at (0, 0) {};
		\node [style=none] (4) at (1, 0.5) {};
		\node [style=none] (6) at (1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=new edge style 0] (0) to (2.center);
		\draw [style=object blue, bend right, looseness=0.75] (4.center) to (3.center);
		\draw [style=object blue, bend left, looseness=0.75] (6.center) to (3.center);
		\draw [style=object blue] (3.center) to (0);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (3) at (1, 0.5) {};
		\node [style=none] (4) at (-1, 0) {};
		\node [style=function clear] (5) at (0, 0.5) {$r$};
		\node [style=none] (6) at (-2, 0) {};
		\node [style=none] (7) at (0, -0.5) {};
		\node [style=function clear] (8) at (0, -0.5) {$r$};
		\node [style=none] (9) at (1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=new edge style 0] (4.center) to (6.center);
		\draw [style=new edge style 0, bend right, looseness=0.75] (5) to (4.center);
		\draw [style=new edge style 0, bend left, looseness=0.75] (7.center) to (4.center);
		\draw [style=object blue] (9.center) to (8);
		\draw [style=object blue] (3.center) to (5);
	\end{pgfonlayer}
\end{tikzpicture}
\]
we can then prove that $r^{\ast}$ is a functor graphically:
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (1) at (2, 0) {};
		\node [style=none] (2) at (-1, 0) {};
		\node [style=function clear] (3) at (0, -0.5) {$r$};
		\node [style=function blue] (4) at (1, -0.5) {};
		\node [style=none] (5) at (-1, -0.5) {};
		\node [style=none] (6) at (-1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (2.center);
		\draw [style=object blue] (4) to (3);
		\draw [style=new edge style 0, in=0, out=180] (3) to (6.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (1) at (1, 0) {};
		\node [style=none] (2) at (-1, 0) {};
		\node [style=new style 0] (4) at (0, -0.5) {};
		\node [style=none] (6) at (-1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (2.center);
		\draw [style=new edge style 0] (4) to (6.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (3.5, 0) {$g$};
		\node [style=none] (1) at (4.5, 0) {};
		\node [style=none] (2) at (2.5, 0) {};
		\node [style=none] (3) at (0.75, -1.5) {};
		\node [style=function clear] (4) at (1.5, 0) {$f$};
		\node [style=none] (5) at (2.5, 0) {};
		\node [style=none] (6) at (-2, 0) {};
		\node [style=none] (8) at (0, -1) {};
		\node [style=none] (9) at (0.75, -0.5) {};
		\node [style=function clear] (10) at (-1, -1) {$r$};
		\node [style=none] (11) at (-2, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (0) to (3.center);
		\draw [style=object] (5.center) to (4);
		\draw [style=object] (4) to (6.center);
		\draw [style=object blue] (8.center) to (10);
		\draw [style=object blue, bend right, looseness=0.75] (9.center) to (8.center);
		\draw [style=object blue, bend left, looseness=0.75] (3.center) to (8.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (4) to (9.center);
		\draw [style=new edge style 0] (10) to (11.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function clear] (0) at (2.5, 0) {$g$};
		\node [style=none] (1) at (3.5, 0) {};
		\node [style=none] (2) at (1.5, 0) {};
		\node [style=function clear] (3) at (1.5, -0.5) {$r$};
		\node [style=function clear] (4) at (0.5, 0) {$f$};
		\node [style=none] (5) at (1.5, 0) {};
		\node [style=none] (6) at (-2, 0) {};
		\node [style=none] (8) at (-1, -1) {};
		\node [style=function clear] (9) at (-0.25, -0.5) {$r$};
		\node [style=none] (11) at (-2, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (1.center) to (0);
		\draw [style=object] (0) to (2.center);
		\draw [style=object blue, in=0, out=-120] (0) to (3);
		\draw [style=object] (5.center) to (4);
		\draw [style=object] (4) to (6.center);
		\draw [style=new edge style 0, bend right, looseness=0.75] (9) to (8.center);
		\draw [style=new edge style 0, in=-45, out=180, looseness=1.25] (3) to (8.center);
		\draw [style=object blue, in=0, out=-120] (4) to (9);
		\draw [style=new edge style 0] (8.center) to (11.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]


\begin{proposition}\label{prop.lenses_as_groth_construction}
  The category $\Cat{Lens}_{\cat{C}}$ of lenses in $\cat{C}$ is the
  Grothendieck construction of the indexed category of \emph{opposites} of the
  categories of maps with context:
  $$\Cat{Lens}_{\cat{C}} = \int^{C \in \cat{C}} \smctx{C}\op.$$
\end{proposition}
\begin{proof}
We will expand the
definition of the right hand side and see that it is precisely the category of lenses.

The objects of $\int^{C \in \smset} \smctx{C}\op$ are pairs $\lens{A^-}{A^+}$ of
objects of $\cat{C}$. All good so far.

A map in $\int^{C \in \cat{C}} \smctx{C}\op$ is a pair $\lens{f^{\sharp}}{f}$
with $f : A^+ \to B^+$ and $f^{\sharp} : A^- \ctxto f^{\ast} B^-$ in
$\smctx{A^+}\op$. Now, $f^{\ast}B^- = B^-$ so $f^{\sharp}$ has signature $A^-
\ctxto B^-$ in $\smctx{A^+}\op$, which means $f^{\sharp}$ has signature $B^-
\ctxto A^{-}$ in $\smctx{A^+}$, which means that $f^{\sharp}$ is a really a
function $A^+ \times B^- \to A^{-}$. In other words, a map in $\int^{C \in \smset}
\smctx{C}\op$ is precisely a lens. We note that the identity map is the identity lens.

Finally, we need to check that composition in $\int^{C \in \cat{C}} \smctx{C}\op$
is lens composition. Suppose that $\lens{f^{\sharp}}{f} :
  \lens{A^-}{A^+} \fromto \lens{B^-}{B^+}$ and $\lens{g^{\sharp}}{g} :
  \lens{B^-}{B^+} \fromto \lens{C^-}{C^+}$ are lenses. In $\int^{C \in \smset}
  \smctx{C}\op$, their composite is
$$\lens{f^{\ast}g^{\sharp} \circ f^{\sharp}}{g \circ f}.$$
  The bottom is all good, we just need to check that the top --- which,
  remember, lives in $\smctx{A^+}\op$ --- is correct. Since the composite up top
  is in
  the opposite, we are really calculating $f^{\sharp} \circ f^{\ast} g^{\sharp}$
  in $\smctx{A^+}$. By definition, this is
$$(a^+, c^-) \mapsto f^{\sharp}(a^+, g^{\sharp}(f(a^+), c^-))$$
which is precisely their composite as lenses!
\end{proof}

\begin{exercise}\label{ex.really_understand_charts_as_groth_construction}
  Make sure you \emph{really} understand \cref{prop.lenses_as_groth_construction}.
\end{exercise}

We take \cref{prop.lenses_as_groth_construction} as paradigmatic of the notion
of lens, and use this idea to define lenses from any indexed category.

\begin{definition}\label{def.groth_lens}
 Let $\cat{A} : \cat{C}\op \to \Cat{Cat}$ be an indexed category. The category of $\cat{A}$-lenses is the Grothendieck construction of
     $\cat{A}\op$:
$$\Cat{Lens}_{\cat{A}} = \int^{C \in \cat{C}} \cat{A}(C)\op.$$
\end{definition}

\begin{example}\label{ex.dependent_lenses_via_groth}
Recall the indexed category $\smset^{(-)} : \smset\op \to \Cat{Cat}$ of
dependent sets from \cref{ex.indexed_cat_of_dependent_sets}. A
$\smset^{(-)}$-lens $\lens{f^{\sharp}}{f} : \lens{A^-_a}{a \in A^+} \fromto
\lens{B^-_b}{b \in B^+}$ consists of
\begin{itemize}
\item A passforward function $f : A^+ \to B^+$, and
  \item A family of passback functions $f^{\sharp}_{a} : B^- \to A^-$ for every
    $a \in A^+$.
\end{itemize}
We call these \emph{dependent lenses}, and they will be a major character in the
later chapters of this book.
\end{example}

\subsection{Monoidal indexed categories and the product of lenses}

To describe wiring diagrams, it is not enough just to have the category of
lenses; we also need the monoidal product 
$$\lens{A^-}{A^+} \otimes \lens{B^-}{B^+} \coloneqq \lens{A^- \times B^-}{A^+
  \times B^+}.$$

We need this product to put systems together before wiring them. In order to
wire together non-deterministic systems, we will need to generalize this product
of lenses to generalized lenses. For this, we will need the notion of an
\emph{monoidal indexed category} and the associated \emph{monoidal Grothendieck
  construction} as defined in \cite{MoellerVasilakopolou}.

\begin{definition}\label{def.monoidal_indexed}
A \emph{monoidal strict indexed category} $(\cat{A} : \cat{C}\op \to \Cat{Cat},
\otimes, \ord{1}, \boxtimes, \mathbb{1})$ consists of:
\begin{itemize}
  \item A strict indexed category $\cat{A} : \cat{C}\op \to \Cat{Cat}$,
\item A monoidal structure $(\otimes, \ord{1})$ on $\cat{C}$,
\item A natural family of functors $\boxtimes : \cat{A}(C) \times \cat{A}(C')
  \to \cat{A}(C \otimes C')$ and $\mathbb{1} \in \cat{A}(\ord{1})$ with natural
  isomorphisms 
$$A_1 \boxtimes (A_2 \boxtimes A_3) \cong (A_1 \boxtimes A_2) \boxtimes A_3,$$
$$\mathbb{1} \boxtimes A \cong A \cong A \boxtimes \mathbb{1}.$$
These natural isomorphisms are required to satisfy coherences reminiscent of
those of a monoidal category.
\end{itemize}
\end{definition}

\begin{theorem}[\cite{MoellerVasilakopolou}]\label{thm.monoidal_indexed}
Let $\cat{A} : \cat{C}\op \to \Cat{Cat}$ be a monoidal indexed category. Then
the Grothendieck construction $\int^{C : \cat{C}} \cat{A}(C)$ may be equipped
with a monoidal structure 
$$\lens{A^-}{A^+} \otimes \lens{B^-}{B^+} \coloneqq \lens{A^- \boxtimes B^-}{A^+
\otimes B^+}.$$
\end{theorem}

If the base of indexing $\cat{C}$ is cartesian, then there is a simpler way to
describe a monoidal structure on an indexed category $\cat{A} : \cat{C}\op \to \Cat{Cat}$.

\begin{theorem}[\cite{ShulmanMonoidal}]\label{thm.monoidal_indexed_cartesian}
Let $\cat{C}$ be a cartesian category. Then a monoidal structures on a strict indexed
category $\cat{A} :
\cat{C}\op \to \Cat{Cat}$ whose underlying monoidal structure on $\cat{C}$ is
given by the cartesian product may be equivalently given by the data:
\begin{itemize}
  \item A monoidal structure $\otimes : \cat{A}(C) \times \cat{A}(C) \to
    \cat{A}(C)$ and $\ord{1} \in \cat{A}(C)$ for each $C \in \cat{C}$, 
  \item A lax structure on each reindexing $r^{\ast} : \cat{A}(C) \to \cat{A}(C')$
    for each $r : C' \to C$, so that the lax structure on $(r_2 \circ
    r_1)^{\ast}$ is the composite of the lax structures on $r_2$ and $r_1$.
\end{itemize}
\end{theorem}
\begin{proof}[Proof Sketch]
We define the product $\otimes : \cat{A}(C) \times \cat{A}(C) \to \cat{A}(C)$ as
$\boxtimes \circ \Delta^{\ast}$ where $\Delta : C \to C \times C$ is the
diagonal. We similarly define $\ord{1} \in \cat{A}(C)$ as $!^{\ast}(\mathbb{1})$.
\end{proof}

We use \cref{thm.monoidal_indexed_cartesian} and \cref{thm.monoidal_indexed} to
recover the product of lenses.
\begin{lemma}\label{lem.context_monoidal}
Let $\cat{C}$ be a cartesian category and let $C \in \cat{C}$. The category
$\smctx{C}$ has a monoidal structure given by $X \otimes Y \coloneqq X \times
Y$, $\ord{1} \coloneqq \ord{1}$, and 
  $$f \otimes g \coloneqq C \times X \times Y \xto{\Delta} C \times C \times X
  \times Y \xto{\sim} C \times X \times C \times Y \xto{f \times g} X' \times Y'.$$
In terms of elements, 
$$(f \otimes g)(c, x, y) \coloneqq (f(c, x), g(c, y)).$$
\end{lemma}
\begin{proof}
  We begin by showing that $\otimes$ is functorial:
\begin{align*}
  ( (f' \circ f) \otimes (g' \circ g))(c, x, y) &= ((f' \circ f)(c, x), (g' \circ g)(c, y))\\
&= (f'(c, f(c, x)), g'(c, g'(c, y))) \\
  &= (f' \otimes g')(f(c, x), g(c, y)) \\
&= (f' \otimes g') \circ (f \otimes g)(x, y).
\end{align*}

Next, we need associators $X \otimes (Y \otimes Z) \cong (X \otimes Y) \otimes
Z$ and unitors $\ord{1} \otimes X \cong X \cong X \otimes \ord{1}$. We may
get these by applying $!^{\ast} : \cat{C} \to \smctx{C}$ (which sends $f : X \to
Y$ to $f \circ \pi_1 : C \times X \to Y$) to the associators and unitors of
$\cat{C}$. It is straightforward to see that these are natural with respect to maps in $\smctx{C}$. 
\end{proof}


\begin{proposition}
Let $\cat{C}$ be a cartesian category. Then $\smctx{-} : \cat{C}\op \to
\Cat{Cat}$ may be endowed with a monoidal structure so that the induced monoidal
structure on the Grothendieck construction is the product of lenses
$$\lens{A^-}{A^+} \otimes \lens{B^-}{B^+} \coloneqq \lens{A^- \times B^-}{A^+
  \times B^+}.$$
\end{proposition}
\begin{proof}
By \cref{lem.context_monoidal}, there is monoidal structure on each $\smctx{C}$.
We note that by definition, each reindexing $r^{\ast} : \smctx{C} \to
\smctx{C'}$ along $r : C' \to C$ preserves this monoidal structure strictly.
\begin{align*}
r^{\ast}(f \otimes g)(c', (x, y)) &= (f \otimes g)(r(c'), (x, y)) \\
&= (f(r(c'), x), g(r(c'), y)) \\
&= (r^{\ast}f \otimes r^{\ast} g)(c, (x, y)).
\end{align*}
The rest then follows by \cref{thm.monoidal_indexed_cartesian} and \cref{thm.monoidal_indexed}.
\end{proof}

\subsection{Monadic lenses as generalized lenses}

Now we are ready to define monadic lenses. We have a formula: we just need to
find the right indexed category. We will do this by modifying the definition of
$\smctx{C}$ so that a map is of the form $C \times X \to M Y$. If the resulting
categories $\smctx{C}^M$ remain indexed over $\cat{C}$, we have a ready made
notion of monadic lens and monadic lens composition given by the Grothendieck construction!

We will be able to define composition in the categories $\smctx{C}^M$ by making
use of the natural map 
\[
\lambda : C \times MX \xto{\eta \times MX} MC \times MX \xto{\sigma} M(C \times X)
\]

Using string diagrams, we may draw this map as 
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0.5) {};
		\node [style=none] (2) at (1, 0.5) {};
		\node [style=none] (3) at (-1, -0.5) {};
		\node [style=none] (4) at (1, -0.5) {};
		\node [style=none] (5) at (0, 0) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue, in=180, out=0, looseness=0.75] (3.center) to (5.center);
		\draw [style=object blue, in=-180, out=0] (5.center) to (2.center);
		\draw [style=object red, in=180, out=0, looseness=0.75] (0.center) to (5.center);
		\draw [style=object red, in=-180, out=0, looseness=0.75] (5.center) to (4.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]

Using do notation, we may describe this map as
\[
  (c, m) \mapsto \unalignedDo{
    $c' \from \eta(c)$,
    $x \from m$,
    ${\eta(c', x)}$
  } = \unalignedDo{
    $x \from m$,
    ${\eta(c, x)}$
  }
\]

\begin{definition}
  Let $\cat{C}$ be a cartesian category and $M : \cat{C} \to \cat{C}$ a
  commutative monad. For an object $C \in \cat{C}$, there is a category
  $\smctx{C}^M$ with:
\begin{itemize}
  \item Objects the objects of $\cat{C}$.
  \item Map $f : X \wavyto Y$ are maps $f : C \times X \to MY$ in $\cat{C}$.
  \item The identity $X \wavyto X$ is $\pi_2 \then \eta$.
  \item The composite $f \then g$ of $f : X \wavyto Y$ and $g : Y \wavyto Z$ is
    given by 
$$f \then g \coloneqq (\Delta_C \times X) \then (C \times f) \then \lambda
\then Mg \then \mu.$$ 
$$C \times X \to C \times C \times X \to C \times MY \to M(C \times Y) \to M^2Z
\to MZ$$
Here, $\lambda \coloneqq (\eta \times MX) \then \sigma$.
Using do notation, we may describe the composite $f \then g$ as 
\[
(c, m) \mapsto \unalignedDo{
  $x \from m$,
  $y \from { f(c, x) }$,
  ${ g(c, y) }$
}
\]
\end{itemize}
\end{definition}

We can show that $\smctx{C}^M$ is indeed a category using string diagrams. In
string diagrams, a map $f : C \times X \to MY$ in $\smctx{C}^M$ is drawn
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (1) at (1, 0) {};
		\node [style=none] (2) at (-1, 0) {};
		\node [style=none] (3) at (-1, -0.5) {};
		\node [style=function clear] (4) at (0, 0) {$f$};
		\node [style=none] (5) at (1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red, in=180, out=-60, looseness=0.75] (4) to (5.center);
		\draw [style=object] (1.center) to (4);
		\draw [style=object] (4) to (2.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (4) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]

and composition is drawn
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (2) at (-1.5, 0) {};
		\node [style=function clear] (4) at (0, 0) {$f$};
		\node [style=none] (6) at (3, 0) {};
		\node [style=none] (7) at (0.75, 0) {};
		\node [style=none] (8) at (0.75, -0.5) {};
		\node [style=function clear] (9) at (1.5, 0) {$g$};
		\node [style=none] (10) at (2, -0.5) {};
		\node [style=none] (11) at (-1, -0.75) {};
		\node [style=none] (12) at (-0.5, -0.5) {};
		\node [style=none] (13) at (-1.5, -0.75) {};
		\node [style=none] (14) at (-0.5, -1) {};
		\node [style=none] (15) at (2, -1) {};
		\node [style=none] (16) at (2.5, -0.75) {};
		\node [style=none] (17) at (2, -0.5) {};
		\node [style=none] (18) at (3, -0.75) {};
		\node [style=none] (19) at (2, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue, in=180, out=0] (14.center) to (8.center);
		\draw [style=object] (4) to (2.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (9) to (10.center);
		\draw [style=object] (6.center) to (9);
		\draw [style=object] (9) to (7.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (9) to (8.center);
		\draw [style=object blue] (11.center) to (13.center);
		\draw [style=object blue, in=45, out=-180, looseness=0.75] (12.center) to (11.center);
		\draw [style=object blue, in=315, out=-180, looseness=0.75] (14.center) to (11.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (4) to (12.center);
		\draw [style=object] (7.center) to (4);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (4) to (8.center);
		\draw [style=object red, in=180, out=0, looseness=1.25] (8.center) to (15.center);
		\draw [style=object red] (16.center) to (18.center);
		\draw [style=object red, in=135, out=0, looseness=0.75] (17.center) to (16.center);
		\draw [style=object red, in=-135, out=0, looseness=0.75] (19.center) to (16.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
The identity is drawn
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1.5, 0) {};
		\node [style=none] (1) at (1.5, 0) {};
		\node [style=none] (2) at (-1.5, -0.5) {};
		\node [style=function blue] (3) at (-0.5, -0.5) {};
		\node [style=function red] (4) at (0.5, -0.5) {};
		\node [style=none] (5) at (1.5, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object] (0.center) to (1.center);
		\draw [style=object blue] (2.center) to (3);
		\draw [style=object red] (4) to (5.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
In order to show that this composition is unital and associative, we will need
to show that the following four laws hold relating $\lambda$ to the structure of
$M$ and of $C \times (-)$:
\begin{equation}\label{eqn.dist_law_unit}
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function red] (0) at (-1, 0.5) {};
		\node [style=none] (2) at (1, 0.5) {};
		\node [style=none] (3) at (-1, -0.5) {};
		\node [style=none] (4) at (1, -0.5) {};
		\node [style=none] (5) at (0, 0) {};
		\node [style=none] (6) at (-2, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue, in=180, out=0, looseness=0.75] (3.center) to (5.center);
		\draw [style=object blue, in=-180, out=0] (5.center) to (2.center);
		\draw [style=object red, in=180, out=0, looseness=0.75] (0) to (5.center);
		\draw [style=object red, in=-180, out=0, looseness=0.75] (5.center) to (4.center);
		\draw [style=object blue] (6.center) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0.5) {};
		\node [style=none] (1) at (1, 0.5) {};
		\node [style=function red] (2) at (0, -0.5) {};
		\node [style=none] (3) at (1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red] (2) to (3.center);
		\draw [style=object blue] (0.center) to (1.center);
	\end{pgfonlayer}
\end{tikzpicture}
\end{equation}
\begin{equation}\label{eqn.dist_law_counit}
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=function blue] (0) at (0, 0.5) {};
		\node [style=none] (2) at (-2, 0.5) {};
		\node [style=none] (3) at (0, -0.5) {};
		\node [style=none] (4) at (-2, -0.5) {};
		\node [style=none] (5) at (-1, 0) {};
		\node [style=none] (6) at (1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red, in=0, out=180, looseness=0.75] (3.center) to (5.center);
		\draw [style=object red, in=0, out=180] (5.center) to (2.center);
		\draw [style=object blue, in=0, out=180, looseness=0.75] (0) to (5.center);
		\draw [style=object blue, in=0, out=180, looseness=0.75] (5.center) to (4.center);
		\draw [style=object red] (6.center) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (1, 0.5) {};
		\node [style=none] (1) at (-1, 0.5) {};
		\node [style=function blue] (2) at (0, -0.5) {};
		\node [style=none] (3) at (-1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue] (2) to (3.center);
		\draw [style=object red] (0.center) to (1.center);
	\end{pgfonlayer}
\end{tikzpicture}
\end{equation}
\begin{equation}\label{eqn.dist_law_mult}
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-1, 0.5) {};
		\node [style=none] (2) at (1, 0.5) {};
		\node [style=none] (3) at (-1, -0.5) {};
		\node [style=none] (4) at (1, -0.5) {};
		\node [style=none] (5) at (0, 0) {};
		\node [style=none] (6) at (-1, 0.5) {};
		\node [style=none] (7) at (-2, 1) {};
		\node [style=none] (9) at (-2, 0) {};
		\node [style=none] (10) at (-2, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue, in=180, out=0, looseness=0.75] (3.center) to (5.center);
		\draw [style=object blue, in=-180, out=0] (5.center) to (2.center);
		\draw [style=object red, in=180, out=0, looseness=0.75] (0.center) to (5.center);
		\draw [style=object red, in=-180, out=0, looseness=0.75] (5.center) to (4.center);
		\draw [style=object red, bend left, looseness=0.75] (7.center) to (6.center);
		\draw [style=object red, bend right, looseness=0.75] (9.center) to (6.center);
		\draw [style=object blue] (10.center) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (-2, 1) {};
		\node [style=none] (2) at (2, 1) {};
		\node [style=none] (3) at (-1, -0.5) {};
		\node [style=none] (4) at (1, -0.5) {};
		\node [style=none] (5) at (0, 0) {};
		\node [style=none] (7) at (-2, 0) {};
		\node [style=none] (9) at (-2, -1) {};
		\node [style=none] (10) at (1, -1.5) {};
		\node [style=none] (11) at (-1, -0.5) {};
		\node [style=none] (12) at (-2, 0) {};
		\node [style=none] (13) at (2, -1) {};
		\node [style=none] (14) at (1, -0.5) {};
		\node [style=none] (15) at (3, -1) {};
		\node [style=none] (16) at (1, -1.5) {};
		\node [style=none] (17) at (3, 1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue, in=180, out=0, looseness=0.75] (3.center) to (5.center);
		\draw [style=object blue, in=-180, out=0] (5.center) to (2.center);
		\draw [style=object red, in=180, out=0, looseness=0.75] (0.center) to (5.center);
		\draw [style=object red, in=-180, out=0, looseness=0.75] (5.center) to (4.center);
		\draw [style=object blue, in=180, out=0, looseness=0.75] (9.center) to (11.center);
		\draw [style=object red, in=180, out=0, looseness=0.75] (7.center) to (11.center);
		\draw [style=object red, in=-180, out=0, looseness=0.75] (11.center) to (10.center);
		\draw [style=object red] (13.center) to (15.center);
		\draw [style=object red, bend left, looseness=0.75] (14.center) to (13.center);
		\draw [style=object red, bend right, looseness=0.75] (16.center) to (13.center);
		\draw [style=object blue] (2.center) to (17.center);
	\end{pgfonlayer}
\end{tikzpicture}
\end{equation}
\begin{equation}\label{eqn.dist_law_comult}
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (0, 0.5) {};
		\node [style=none] (2) at (-2, 0.5) {};
		\node [style=none] (3) at (0, -0.5) {};
		\node [style=none] (4) at (-2, -0.5) {};
		\node [style=none] (5) at (-1, 0) {};
		\node [style=none] (6) at (0, 0.5) {};
		\node [style=none] (7) at (1, 1) {};
		\node [style=none] (9) at (1, 0) {};
		\node [style=none] (10) at (1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red, in=0, out=180, looseness=0.75] (3.center) to (5.center);
		\draw [style=object red, in=0, out=180] (5.center) to (2.center);
		\draw [style=object blue, in=0, out=180, looseness=0.75] (0.center) to (5.center);
		\draw [style=object blue, in=0, out=180, looseness=0.75] (5.center) to (4.center);
		\draw [style=object blue, bend right, looseness=0.75] (7.center) to (6.center);
		\draw [style=object blue, bend left, looseness=0.75] (9.center) to (6.center);
		\draw [style=object red] (10.center) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (3, 1) {};
		\node [style=none] (2) at (-1, 1) {};
		\node [style=none] (3) at (2, -0.5) {};
		\node [style=none] (4) at (0, -0.5) {};
		\node [style=none] (5) at (1, 0) {};
		\node [style=none] (7) at (3, 0) {};
		\node [style=none] (9) at (3, -1) {};
		\node [style=none] (10) at (0, -1.5) {};
		\node [style=none] (11) at (2, -0.5) {};
		\node [style=none] (12) at (3, 0) {};
		\node [style=none] (13) at (-1, -1) {};
		\node [style=none] (14) at (0, -0.5) {};
		\node [style=none] (15) at (-2, -1) {};
		\node [style=none] (16) at (0, -1.5) {};
		\node [style=none] (17) at (-2, 1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red, in=0, out=180, looseness=0.75] (3.center) to (5.center);
		\draw [style=object red, in=0, out=180] (5.center) to (2.center);
		\draw [style=object blue, in=0, out=180, looseness=0.75] (0.center) to (5.center);
		\draw [style=object blue, in=0, out=180, looseness=0.75] (5.center) to (4.center);
		\draw [style=object red, in=0, out=180, looseness=0.75] (9.center) to (11.center);
		\draw [style=object blue, in=0, out=180, looseness=0.75] (7.center) to (11.center);
		\draw [style=object blue, in=0, out=180, looseness=0.75] (11.center) to (10.center);
		\draw [style=object blue] (13.center) to (15.center);
		\draw [style=object blue, bend right, looseness=0.75] (14.center) to (13.center);
		\draw [style=object blue, bend left, looseness=0.75] (16.center) to (13.center);
		\draw [style=object red] (2.center) to (17.center);
	\end{pgfonlayer}
\end{tikzpicture}
\end{equation}

We will prove these laws in the upcoming \cref{lem.dist_law}.%
\footnote{And we
  will re-express them as commutative diagrams there.} Using them, we can see
that composition in $\smctx{C}^M$ is unital and associative.
\[
\begin{tikzpicture}[baseline=(current bounding box.center)]
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (2) at (-1.5, 0) {};
		\node [style=function clear] (4) at (0, 0) {$f$};
		\node [style=none] (6) at (3, 0) {};
		\node [style=none] (7) at (0.75, 0) {};
		\node [style=none] (8) at (0.75, -0.75) {};
		\node [style=none] (11) at (-1, -0.75) {};
		\node [style=none] (12) at (-0.5, -0.5) {};
		\node [style=none] (13) at (-1.5, -0.75) {};
		\node [style=none] (14) at (-0.5, -1) {};
		\node [style=none] (16) at (2.5, -0.75) {};
		\node [style=function red] (17) at (2, -0.5) {};
		\node [style=none] (18) at (3, -0.75) {};
		\node [style=none] (19) at (1.75, -1) {};
		\node [style=function blue] (20) at (1.5, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue, in=180, out=0] (14.center) to (8.center);
		\draw [style=object] (4) to (2.center);
		\draw [style=object blue] (11.center) to (13.center);
		\draw [style=object blue, in=45, out=-180, looseness=0.75] (12.center) to (11.center);
		\draw [style=object blue, in=315, out=-180, looseness=0.75] (14.center) to (11.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (4) to (12.center);
		\draw [style=object] (7.center) to (4);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (4) to (8.center);
		\draw [style=object red] (16.center) to (18.center);
		\draw [style=object red, in=135, out=0, looseness=1.25] (17) to (16.center);
		\draw [style=object red, in=-135, out=0, looseness=0.75] (19.center) to (16.center);
		\draw [style=object blue, in=-180, out=0] (8.center) to (20);
		\draw [style=object] (7.center) to (6.center);
		\draw [style=object red, in=180, out=0, looseness=1.25] (8.center) to (19.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (6) at (-0.5, 0) {};
		\node [style=none] (7) at (3, 0) {};
		\node [style=function clear] (9) at (1, 0) {$f$};
		\node [style=none] (10) at (0.5, -0.5) {};
		\node [style=none] (11) at (2.5, -0.75) {};
		\node [style=function red] (12) at (2, -0.5) {};
		\node [style=none] (13) at (3, -0.75) {};
		\node [style=none] (14) at (2, -1) {};
		\node [style=none] (15) at (0.5, -1) {};
		\node [style=none] (16) at (0, -0.75) {};
		\node [style=none] (17) at (0.5, -0.5) {};
		\node [style=none] (18) at (-0.5, -0.75) {};
		\node [style=function blue] (19) at (0.5, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (9) to (10.center);
		\draw [style=object] (6.center) to (9);
		\draw [style=object] (9) to (7.center);
		\draw [style=object red] (11.center) to (13.center);
		\draw [style=object red, in=135, out=0, looseness=0.75] (12) to (11.center);
		\draw [style=object red, in=-135, out=0, looseness=0.75] (14.center) to (11.center);
		\draw [style=object blue] (16.center) to (18.center);
		\draw [style=object blue, in=45, out=180, looseness=0.75] (17.center) to (16.center);
		\draw [style=object blue, in=-45, out=180, looseness=0.75] (19) to (16.center);
		\draw [style=object red, in=180, out=-45] (9) to (14.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (1) at (1, 0) {};
		\node [style=none] (2) at (-1, 0) {};
		\node [style=none] (3) at (-1, -0.5) {};
		\node [style=function clear] (4) at (0, 0) {$f$};
		\node [style=none] (5) at (1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red, in=180, out=-60, looseness=0.75] (4) to (5.center);
		\draw [style=object] (1.center) to (4);
		\draw [style=object] (4) to (2.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (4) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (0) at (2.25, 0) {};
		\node [style=function clear] (1) at (0.75, 0) {$f$};
		\node [style=none] (2) at (-2.25, 0) {};
		\node [style=none] (3) at (0, 0) {};
		\node [style=none] (4) at (0, -0.75) {};
		\node [style=none] (5) at (1.75, -0.75) {};
		\node [style=none] (6) at (1.25, -0.5) {};
		\node [style=none] (7) at (2.25, -0.75) {};
		\node [style=none] (8) at (1.25, -1) {};
		\node [style=none] (9) at (-1.75, -0.75) {};
		\node [style=function blue] (10) at (-1.25, -0.5) {};
		\node [style=none] (11) at (-2.25, -0.75) {};
		\node [style=none] (12) at (-1, -1) {};
		\node [style=function red] (13) at (-0.75, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red, in=0, out=180] (8.center) to (4.center);
		\draw [style=object] (1) to (0.center);
		\draw [style=object red] (5.center) to (7.center);
		\draw [style=object red, in=135, out=0, looseness=0.75] (6.center) to (5.center);
		\draw [style=object red, in=-135, out=0, looseness=0.75] (8.center) to (5.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (1) to (6.center);
		\draw [style=object] (3.center) to (1);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (1) to (4.center);
		\draw [style=object blue] (9.center) to (11.center);
		\draw [style=object blue, in=45, out=180, looseness=1.25] (10) to (9.center);
		\draw [style=object blue, in=-45, out=180, looseness=0.75] (12.center) to (9.center);
		\draw [style=object red, in=0, out=180] (4.center) to (13);
		\draw [style=object] (3.center) to (2.center);
		\draw [style=object blue, in=0, out=180, looseness=1.25] (4.center) to (12.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (6) at (3, 0) {};
		\node [style=none] (7) at (-0.5, 0) {};
		\node [style=function clear] (9) at (1.5, 0) {$f$};
		\node [style=none] (10) at (2, -0.5) {};
		\node [style=none] (11) at (0, -0.75) {};
		\node [style=function blue] (12) at (0.5, -0.5) {};
		\node [style=none] (13) at (-0.5, -0.75) {};
		\node [style=none] (14) at (0.5, -1) {};
		\node [style=none] (15) at (2, -1) {};
		\node [style=none] (16) at (2.5, -0.75) {};
		\node [style=none] (17) at (2, -0.5) {};
		\node [style=none] (18) at (3, -0.75) {};
		\node [style=function red] (19) at (2, -1) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red, in=180, out=-60, looseness=0.75] (9) to (10.center);
		\draw [style=object] (6.center) to (9);
		\draw [style=object] (9) to (7.center);
		\draw [style=object blue] (11.center) to (13.center);
		\draw [style=object blue, in=45, out=-180, looseness=0.75] (12) to (11.center);
		\draw [style=object blue, in=315, out=-180, looseness=0.75] (14.center) to (11.center);
		\draw [style=object red] (16.center) to (18.center);
		\draw [style=object red, in=135, out=0, looseness=0.75] (17.center) to (16.center);
		\draw [style=object red, in=-135, out=0, looseness=0.75] (19) to (16.center);
		\draw [style=object blue, in=0, out=-135] (9) to (14.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (1) at (1, 0) {};
		\node [style=none] (2) at (-1, 0) {};
		\node [style=none] (3) at (-1, -0.5) {};
		\node [style=function clear] (4) at (0, 0) {$f$};
		\node [style=none] (5) at (1, -0.5) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red, in=180, out=-60, looseness=0.75] (4) to (5.center);
		\draw [style=object] (1.center) to (4);
		\draw [style=object] (4) to (2.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (4) to (3.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
\[
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (2) at (-4, 0) {};
		\node [style=function clear] (4) at (-2, 0) {$f$};
		\node [style=none] (6) at (1, 0) {};
		\node [style=none] (7) at (-1.25, 0) {};
		\node [style=none] (8) at (-1.25, -0.5) {};
		\node [style=function clear] (9) at (-0.5, 0) {$g$};
		\node [style=none] (10) at (0, -0.5) {};
		\node [style=none] (15) at (0, -1) {};
		\node [style=none] (16) at (0.5, -0.75) {};
		\node [style=none] (17) at (0, -0.5) {};
		\node [style=none] (19) at (0, -1) {};
		\node [style=none] (20) at (3.75, 0) {};
		\node [style=none] (21) at (1, 0) {};
		\node [style=none] (22) at (1.25, -1) {};
		\node [style=function clear] (23) at (2, 0) {$h$};
		\node [style=none] (24) at (2.75, -0.75) {};
		\node [style=none] (25) at (-1.25, -1.5) {};
		\node [style=none] (26) at (2.75, -1.25) {};
		\node [style=none] (27) at (3.25, -1) {};
		\node [style=none] (28) at (2.75, -0.75) {};
		\node [style=none] (29) at (3.75, -1) {};
		\node [style=none] (30) at (2.75, -1.25) {};
		\node [style=none] (31) at (-2.5, -0.5) {};
		\node [style=none] (32) at (-2.5, -1) {};
		\node [style=none] (33) at (-3, -0.75) {};
		\node [style=none] (34) at (-2.5, -0.5) {};
		\node [style=none] (35) at (-2.5, -1) {};
		\node [style=none] (37) at (-3, -0.75) {};
		\node [style=none] (38) at (-3, -1.25) {};
		\node [style=none] (39) at (-3.5, -1) {};
		\node [style=none] (40) at (-3, -0.75) {};
		\node [style=none] (41) at (-1.25, -1.5) {};
		\node [style=none] (42) at (-4, -1) {};
		\node [style=none] (43) at (0.5, -1.25) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue, in=-180, out=15] (43.center) to (22.center);
		\draw [style=object blue, in=180, out=0, looseness=1.25] (35.center) to (8.center);
		\draw [style=object] (4) to (2.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (9) to (10.center);
		\draw [style=object] (6.center) to (9);
		\draw [style=object] (9) to (7.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (9) to (8.center);
		\draw [style=object] (7.center) to (4);
		\draw [style=object red, in=135, out=0, looseness=0.75] (17.center) to (16.center);
		\draw [style=object red, in=-135, out=0, looseness=0.75] (19.center) to (16.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (23) to (24.center);
		\draw [style=object] (20.center) to (23);
		\draw [style=object] (23) to (21.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (23) to (22.center);
		\draw [style=object red, in=-180, out=0] (22.center) to (26.center);
		\draw [style=object red] (27.center) to (29.center);
		\draw [style=object red, in=135, out=0, looseness=0.75] (28.center) to (27.center);
		\draw [style=object red, in=-135, out=0, looseness=0.75] (30.center) to (27.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (4) to (8.center);
		\draw [style=object red, in=180, out=0, looseness=1.25] (8.center) to (15.center);
		\draw [style=object blue, in=45, out=180, looseness=0.75] (34.center) to (33.center);
		\draw [style=object blue, in=-45, out=180, looseness=0.75] (35.center) to (33.center);
		\draw [style=object blue, in=-120, out=0] (34.center) to (4);
		\draw [style=object blue, in=45, out=180, looseness=0.75] (40.center) to (39.center);
		\draw [style=object blue, in=-45, out=180, looseness=0.75] (41.center) to (39.center);
		\draw [style=object blue] (42.center) to (39.center);
		\draw [style=object red, in=180, out=0, looseness=1.25] (16.center) to (22.center);
		\draw [style=object blue, in=-165, out=0] (41.center) to (43.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (2) at (-4, 0) {};
		\node [style=function clear] (4) at (-2, 0) {$f$};
		\node [style=none] (6) at (1, 0) {};
		\node [style=none] (7) at (-1.25, 0) {};
		\node [style=none] (8) at (-1.25, -0.5) {};
		\node [style=function clear] (9) at (-0.5, 0) {$g$};
		\node [style=none] (10) at (2.25, -1) {};
		\node [style=none] (15) at (2.25, -1.5) {};
		\node [style=none] (16) at (2.75, -1.25) {};
		\node [style=none] (17) at (2.25, -1) {};
		\node [style=none] (19) at (2.25, -1.5) {};
		\node [style=none] (20) at (3.75, 0) {};
		\node [style=none] (21) at (1, 0) {};
		\node [style=none] (24) at (2.75, -0.75) {};
		\node [style=none] (25) at (-1.25, -1.5) {};
		\node [style=none] (26) at (2.75, -1.25) {};
		\node [style=none] (27) at (3.25, -1) {};
		\node [style=none] (28) at (2.75, -0.75) {};
		\node [style=none] (29) at (3.75, -1) {};
		\node [style=none] (30) at (2.75, -1.25) {};
		\node [style=none] (31) at (-2.5, -0.5) {};
		\node [style=none] (32) at (-2.5, -1) {};
		\node [style=none] (33) at (-3, -0.75) {};
		\node [style=none] (34) at (-2.5, -0.5) {};
		\node [style=none] (35) at (-2.5, -1) {};
		\node [style=none] (37) at (-3, -0.75) {};
		\node [style=none] (38) at (-3, -1.25) {};
		\node [style=none] (39) at (-3.5, -1) {};
		\node [style=none] (40) at (-3, -0.75) {};
		\node [style=none] (41) at (-1.25, -1.5) {};
		\node [style=none] (42) at (-4, -1) {};
		\node [style=function clear] (43) at (2, 0) {$h$};
		\node [style=none] (44) at (1, -0.75) {};
		\node [style=none] (45) at (0.25, -1.25) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object blue, in=180, out=0, looseness=1.25] (35.center) to (8.center);
		\draw [style=object] (4) to (2.center);
		\draw [style=object] (6.center) to (9);
		\draw [style=object] (9) to (7.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (9) to (8.center);
		\draw [style=object] (7.center) to (4);
		\draw [style=object red, in=135, out=0, looseness=0.75] (17.center) to (16.center);
		\draw [style=object red, in=-135, out=0, looseness=0.75] (19.center) to (16.center);
		\draw [style=object red] (27.center) to (29.center);
		\draw [style=object red, in=135, out=0, looseness=0.75] (28.center) to (27.center);
		\draw [style=object red, in=-135, out=0, looseness=0.75] (30.center) to (27.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (4) to (8.center);
		\draw [style=object blue, in=45, out=180, looseness=0.75] (34.center) to (33.center);
		\draw [style=object blue, in=-45, out=180, looseness=0.75] (35.center) to (33.center);
		\draw [style=object blue, in=-120, out=0] (34.center) to (4);
		\draw [style=object blue, in=45, out=180, looseness=0.75] (40.center) to (39.center);
		\draw [style=object blue, in=-45, out=180, looseness=0.75] (41.center) to (39.center);
		\draw [style=object blue] (42.center) to (39.center);
		\draw [style=object red, in=0, out=180, looseness=0.50] (17.center) to (44.center);
		\draw [style=object red, in=-30, out=180, looseness=0.50] (44.center) to (9);
		\draw [style=object red, in=0, out=180, looseness=0.75] (19.center) to (45.center);
		\draw [style=object red, in=0, out=-165, looseness=0.25] (45.center) to (8.center);
		\draw [style=object blue, in=180, out=0, looseness=0.50] (41.center) to (45.center);
		\draw [style=object blue, in=180, out=0, looseness=0.75] (45.center) to (44.center);
		\draw [style=object blue] (44.center) to (43);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (43) to (24.center);
		\draw [style=object] (20.center) to (43);
		\draw [style=object] (43) to (21.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]
\[
 =
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (2) at (3.75, 0) {};
		\node [style=function clear] (4) at (1.75, 0) {$h$};
		\node [style=none] (6) at (-1.25, 0) {};
		\node [style=none] (7) at (1, 0) {};
		\node [style=none] (8) at (1, -0.5) {};
		\node [style=function clear] (9) at (0.25, 0) {$g$};
		\node [style=none] (10) at (-2.5, -1) {};
		\node [style=none] (15) at (-2.5, -1.5) {};
		\node [style=none] (16) at (-3, -1.25) {};
		\node [style=none] (17) at (-2.5, -1) {};
		\node [style=none] (19) at (-2.5, -1.5) {};
		\node [style=none] (20) at (-4, 0) {};
		\node [style=none] (21) at (-1.25, 0) {};
		\node [style=function clear] (23) at (-2.25, 0) {$f$};
		\node [style=none] (24) at (-3, -0.75) {};
		\node [style=none] (25) at (1, -1.5) {};
		\node [style=none] (26) at (-3, -1.25) {};
		\node [style=none] (27) at (-3.5, -1) {};
		\node [style=none] (28) at (-3, -0.75) {};
		\node [style=none] (29) at (-4, -1) {};
		\node [style=none] (30) at (-3, -1.25) {};
		\node [style=none] (31) at (2.25, -0.5) {};
		\node [style=none] (32) at (2.25, -1) {};
		\node [style=none] (33) at (2.75, -0.75) {};
		\node [style=none] (34) at (2.25, -0.5) {};
		\node [style=none] (35) at (2.25, -1) {};
		\node [style=none] (37) at (2.75, -0.75) {};
		\node [style=none] (38) at (2.75, -1.25) {};
		\node [style=none] (39) at (3.25, -1) {};
		\node [style=none] (40) at (2.75, -0.75) {};
		\node [style=none] (41) at (1, -1.5) {};
		\node [style=none] (42) at (3.75, -1) {};
		\node [style=none] (43) at (-2.25, 0) {};
		\node [style=none] (44) at (-1.25, -0.75) {};
		\node [style=none] (45) at (-0.5, -1.25) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red, in=0, out=180, looseness=1.25] (35.center) to (8.center);
		\draw [style=object] (4) to (2.center);
		\draw [style=object] (6.center) to (9);
		\draw [style=object] (9) to (7.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (9) to (8.center);
		\draw [style=object] (7.center) to (4);
		\draw [style=object blue, in=45, out=180, looseness=0.75] (17.center) to (16.center);
		\draw [style=object blue, in=-45, out=180, looseness=0.75] (19.center) to (16.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (23) to (24.center);
		\draw [style=object] (20.center) to (23);
		\draw [style=object] (23) to (21.center);
		\draw [style=object blue] (27.center) to (29.center);
		\draw [style=object blue, in=45, out=180, looseness=0.75] (28.center) to (27.center);
		\draw [style=object blue, in=-45, out=180, looseness=0.75] (30.center) to (27.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (4) to (8.center);
		\draw [style=object red, in=135, out=0, looseness=0.75] (34.center) to (33.center);
		\draw [style=object red, in=-135, out=0, looseness=0.75] (35.center) to (33.center);
		\draw [style=object red, in=-60, out=180] (34.center) to (4);
		\draw [style=object red, in=135, out=0, looseness=0.75] (40.center) to (39.center);
		\draw [style=object red, in=-135, out=0, looseness=0.75] (41.center) to (39.center);
		\draw [style=object red] (42.center) to (39.center);
		\draw [style=object blue, in=180, out=0, looseness=0.50] (17.center) to (44.center);
		\draw [style=object blue, in=210, out=0, looseness=0.50] (44.center) to (9);
		\draw [style=object blue, in=180, out=0, looseness=0.75] (19.center) to (45.center);
		\draw [style=object blue, in=180, out=-15, looseness=0.25] (45.center) to (8.center);
		\draw [style=object red, in=0, out=-180, looseness=0.50] (41.center) to (45.center);
		\draw [style=object red, in=0, out=-180, looseness=0.75] (45.center) to (44.center);
		\draw [style=object red] (44.center) to (43.center);
	\end{pgfonlayer}
\end{tikzpicture}
=
\begin{tikzpicture}[baseline=(current bounding box.center)] 
	\begin{pgfonlayer}{nodelayer}
		\node [style=none] (2) at (3.75, 0) {};
		\node [style=function clear] (4) at (1.75, 0) {$h$};
		\node [style=none] (6) at (-1.25, 0) {};
		\node [style=none] (7) at (1, 0) {};
		\node [style=none] (8) at (1, -0.5) {};
		\node [style=function clear] (9) at (0.25, 0) {$g$};
		\node [style=none] (10) at (-0.25, -0.5) {};
		\node [style=none] (15) at (-0.25, -1) {};
		\node [style=none] (16) at (-0.75, -0.75) {};
		\node [style=none] (17) at (-0.25, -0.5) {};
		\node [style=none] (19) at (-0.25, -1) {};
		\node [style=none] (20) at (-4, 0) {};
		\node [style=none] (21) at (-1.25, 0) {};
		\node [style=none] (22) at (-1.5, -1) {};
		\node [style=function clear] (23) at (-2.25, 0) {$f$};
		\node [style=none] (24) at (-3, -0.75) {};
		\node [style=none] (25) at (1, -1.5) {};
		\node [style=none] (26) at (-3, -1.25) {};
		\node [style=none] (27) at (-3.5, -1) {};
		\node [style=none] (28) at (-3, -0.75) {};
		\node [style=none] (29) at (-4, -1) {};
		\node [style=none] (30) at (-3, -1.25) {};
		\node [style=none] (31) at (2.25, -0.5) {};
		\node [style=none] (32) at (2.25, -1) {};
		\node [style=none] (33) at (2.75, -0.75) {};
		\node [style=none] (34) at (2.25, -0.5) {};
		\node [style=none] (35) at (2.25, -1) {};
		\node [style=none] (37) at (2.75, -0.75) {};
		\node [style=none] (38) at (2.75, -1.25) {};
		\node [style=none] (39) at (3.25, -1) {};
		\node [style=none] (40) at (2.75, -0.75) {};
		\node [style=none] (41) at (1, -1.5) {};
		\node [style=none] (42) at (3.75, -1) {};
		\node [style=none] (43) at (-0.75, -1.25) {};
	\end{pgfonlayer}
	\begin{pgfonlayer}{edgelayer}
		\draw [style=object red, in=0, out=165] (43.center) to (22.center);
		\draw [style=object red, in=0, out=180, looseness=1.25] (35.center) to (8.center);
		\draw [style=object] (4) to (2.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (9) to (10.center);
		\draw [style=object] (6.center) to (9);
		\draw [style=object] (9) to (7.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (9) to (8.center);
		\draw [style=object] (7.center) to (4);
		\draw [style=object blue, in=45, out=180, looseness=0.75] (17.center) to (16.center);
		\draw [style=object blue, in=-45, out=180, looseness=0.75] (19.center) to (16.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (23) to (24.center);
		\draw [style=object] (20.center) to (23);
		\draw [style=object] (23) to (21.center);
		\draw [style=object red, in=180, out=-60, looseness=0.75] (23) to (22.center);
		\draw [style=object blue, in=0, out=180] (22.center) to (26.center);
		\draw [style=object blue] (27.center) to (29.center);
		\draw [style=object blue, in=45, out=180, looseness=0.75] (28.center) to (27.center);
		\draw [style=object blue, in=-45, out=180, looseness=0.75] (30.center) to (27.center);
		\draw [style=object blue, in=0, out=-120, looseness=0.75] (4) to (8.center);
		\draw [style=object blue, in=0, out=180, looseness=1.25] (8.center) to (15.center);
		\draw [style=object red, in=135, out=0, looseness=0.75] (34.center) to (33.center);
		\draw [style=object red, in=-135, out=0, looseness=0.75] (35.center) to (33.center);
		\draw [style=object red, in=-60, out=180] (34.center) to (4);
		\draw [style=object red, in=135, out=0, looseness=0.75] (40.center) to (39.center);
		\draw [style=object red, in=-135, out=0, looseness=0.75] (41.center) to (39.center);
		\draw [style=object red] (42.center) to (39.center);
		\draw [style=object blue, in=0, out=180, looseness=1.25] (16.center) to (22.center);
		\draw [style=object red, in=-15, out=180] (41.center) to (43.center);
	\end{pgfonlayer}
\end{tikzpicture}
\]

This shows that $\smctx{C}^M$ is a category. We now prove the crucial laws which undergird the above graphical arguments.

\begin{lemma}\label{lem.dist_law}
Let $M : \cat{C} \to \cat{C}$ be a commutative monad on a cartesian category
$\cat{C}$. Then the map $\lambda : C \times M X \to M(C \times X)$ defined by
$$\lambda \coloneqq (\eta \times MX) \then \sigma$$
is natural in both $X$ and $C$. Furthermore, the following four diagrams
commute:
\begin{equation}\label{eqn.dist_law_right}
\begin{tikzcd}
C \times X \arrow[rd, "\eta"'] \arrow[r, "C \times \eta"] & C \times MX \arrow[d, "\lambda"] \\
                                                          & M(C \times X)                   
\end{tikzcd}
\end{equation}\label{eqn.dist_law_left}
\begin{equation}
\begin{tikzcd}
C \times MX \arrow[r, "\lambda"] \arrow[rd, "\pi_2"'] & M(C \times X) \arrow[d, "M\pi_2"] \\
                                                      & MX                               
\end{tikzcd}
\end{equation}

\begin{equation}\label{eqn.dist_law_mult_right}
\begin{tikzcd}
C \times M^2X \arrow[d, "\lambda"'] \arrow[rr, "C \times \mu"] &                                   & C \times M X \arrow[d, "\lambda"] \\
M(C \times M X) \arrow[r, "M\lambda"']                          & M^2(C \times X) \arrow[r, "\mu"'] & M(C \times X)                    
\end{tikzcd}
\end{equation}

\begin{equation}\label{eqn.dist_law_mult_right}
\begin{tikzcd}
C \times MX \arrow[rr, "\lambda"] \arrow[d, "\Delta_C \times MX"'] &                                              & M(C \times X) \arrow[d, "M(\Delta_C \times X)"] \\
C \times C \times MX \arrow[r, "C \times \lambda"']                & C \times M(C \times X) \arrow[r, "\lambda"'] & M(C \times C \times X)                         
\end{tikzcd}
\end{equation}
\end{lemma}

\begin{exercise}
Prove \cref{lem.dist_law} by showing that the diagrams commute. This uses the
properties of the commutativity $\sigma$ and naturality. You may find the do
notation helpful.
\end{exercise}

In order to wire diagrams together, we also need the monoidal product on lenses. 
\begin{lemma}
  Let $\cat{C}$ be a cartesian category and let $M : \cat{C} \to \cat{C}$ be a
  commutative monad. Then for any $C \in \cat{C}$, there is a symmetric monoidal
  structure on $\smctx{C}^M$ given by $X \otimes Y \coloneqq X \times Y$, with
  unit $\ord{1}$, and 
$$f \otimes g \coloneqq C \times X \times Y \xto{\Delta} C \times C \times X
\times Y \xto{\sim} C \times X \times C \times Y \xto{f \times g} M X \times M Y
\xto{\sigma} M(X \times Y).$$

With the do notation, $f \otimes g$ may be defined as 
\[
(c, x, y) \mapsto \unalignedDo{
  $z \from {f(c, x)}$,
  $w \from {g(c, y)}$,
  ${\eta(z, w)}$
}
\]
\end{lemma}
\begin{proof}
We will use the do notation to argue this. The proofs in the do notation can,
with some care, be extended out into diagram chases if the reader desires to do
so.

We will show that $\otimes$ is functorial. Let $f : X_1 \to Y_1$, $g : X_2 \to
Y_2$, $f' : Y_1 \to Z_1$ and $g' : Y_2 \to Z_2$. Then
\begin{align*}
 (f \otimes g) \then (f' \otimes g') &= (c, x_1, x_2) \mapsto \unalignedDo{
                                       $y_1 \from {f(c, x_1)}$,
                                       $y_2 \from {g(c, x_2)}$,
                                       $z_1 \from {f'(c, y_1)}$,
                                       $z_2 \from {g'(c, y_2)}$,
                                       ${\eta(z_1, z_2)}$
} \\ 
  &= (c, x_1, x_2) \mapsto \unalignedDo{
     $y_1 \from {f(c, x_1)}$,
     $z_1 \from { f'(c, y_1) }$,
     $y_2 \from {g(c, x_2)}$,
     $z_2 \from {g'(c, y_2)}$,
     ${\eta(z_1, z_2)}$
    } \\
  &= (f \then f') \otimes (g \then g')
\end{align*}
Note the use of commutativity.

Next, we need to give associators $\alpha : (X \otimes Y) \otimes Z \to X
\otimes (Y \otimes Z)$ and unitors $\ell : \ord{1} \otimes X \to X$ and $r : X
\otimes \ord{1} \to X$.
\begin{align*}
  \alpha(c, (x, y), z) &\coloneqq \eta(x, (y, z)).\\
  \ell(c, (\ast, x)) &\coloneqq \eta(x) \\
  r(c, (x, \ast)) &\coloneqq \eta(x)
\end{align*}
These can easily be seen to satisfy the required coherences, and they are just
defined by shuffling the parentheses about.
\end{proof}

From this, we may finally prove the following theorem.

\begin{theorem}\label{thm.bikleisli_indexed_cat}
Let $M : \cat{C} \to \cat{C}$ be a commutative monad on a cartesian category.
Then there is a monoidal strict indexed category 
\[
\smctx{-}^M : \cat{C}\op \to \Cat{Cat}
\]
which sends an object $C \in \cat{C}$ to the category $\smctx{C}^M$ and which
sends a map $r : C' \to C$ to the functor 
\[
r^{\ast} : \smctx{C}^M \to \smctx{C'}^M
\]
which acts as the identity on objects and which sends a morphism $f : C \times X
\to MY$ to the composite $C' \times X \xto{r \times X} C \times X \xto{f} MY$.
\end{theorem}
\begin{proof}
  All that remains to be proven is functoriality in $C$. Letting $r : C' \to C$,
  we get a functor $r^{\ast} : \smctx{C}^M \to \smctx{C'}^M$ given by sending $f
  : C \times X \to MY$ to $f \circ (r \times X) : C' \times X \to MY$. In terms
  of elements, this means
 \[
r^{\ast}f(c', x) \coloneqq f(r(c'), x)
\]
Using the do notation, we can quickly show that this is functorial:
\begin{align*}
  r^{\ast}(g \circ f)(c', x) &= (g\circ f)(r(c'), x) \\
  &= \unalignedDo{
    ${y \from f(r(c'), x)}$,
    ${g(r(c'), y)}$
    } \\
  &= \unalignedDo{
    ${y \from r^{\ast}f(c', x)}$,
    ${r^{\ast}g(c', y)}$
    } \\
&= (r^{\ast}g \circ r^{\ast}f)(c', x)
\end{align*}
To show that it is monoidal, we may also use the do notation:
\begin{align*}
  r^{\ast}(f \otimes g)(c', x, y) &= (f \otimes g)(r(c'), x, y)\\
&= \unalignedDo{
     ${z \from f(r(c'), x)}$,
     ${w \from g(r(c'), y)}$,
      ${\eta(z, w)}$
} \\
  &= \unalignedDo{
     ${z \from r^{\ast}f(c', x)}$,
     ${w \from r^{\ast}g(c', y)}$,
    ${\eta(z, w)}$
    }\\
    &= (r^{\ast}f) \otimes (r^{\ast}g)(c', x, y)
\end{align*}
\end{proof}


With \cref{thm.bikleisli_indexed_cat} in hand, we may now define the category of
monadic lenses.

\begin{definition}
  For a commutative monad $M : \cat{C} \to \cat{C}$ on a cartesian category, we
  define the symmetric monoidal category of $M$-lenses to be the symmetric monoidal category of $\smctx{-}^M$-lenses:
\[
\Cat{Lens}^M_{\cat{C}} \coloneqq \int^{C : \cat{C}}{\smctx{C}^M}\op
\]
\end{definition}

\begin{exercise}
  Show that the category of $M$-lenses may be described as follows:
\begin{itemize}
  \item Its objects are pairs $\lens{A^-}{A^+}$ of objects of $\cat{C}$.
  \item Its maps are $M$-lenses $\lens{f^{\sharp}}{f} : \lens{A^-}{A^+} \fromto
    \lens{B^-}{B^+}$ where $f : A^+ \to B^+$ and $f^{\sharp} : A^+ \times B^-
    \to MA^-$.
  \item The identity is $\lens{\eta \circ \pi_2}{\id}$.
  \item Composition is defined by
\[
\lens{f^{\sharp}}{f} \then \lens{g^{\sharp}}{g} \coloneqq \lens{h}{f \then g}
\]
where $h$ is defined in the do notation as
\[
h(a^+, c^-) \coloneqq \unalignedDo{
  ${b^- \from g^{\sharp}(f(a^+), c^-)}$,
  ${f^{\sharp}(a^+, b^-)}$
}
\]
\end{itemize}
\end{exercise}

\section{Changing the Flavor of Non-determinism}

In \cref{sec.monad_map}, we saw how commutative monad maps $\phi : M \to N$ let
us change the flavor of non-determinism. In particular, since the unit $\eta :
\id \to M$ is always a commutative monad map, we can always interpret a
deterministic system as a non-deterministic system. 

In this section, we'll show that any commutative monad morphism $\phi : M \to N$
induces a symmetric monoidal functor $\Cat{Lens}_{\cat{C}}^M \to
\Cat{Lens}_{\cat{C}}^N$. We will do this using the functoriality of the
Grothendieck construction: any \emph{indexed functor} induces a functor on the
Grothendieck constructions.

\begin{definition}\label{def.indexed_functor}
  Let $\cat{A} : \cat{C}\op \to \Cat{Cat}$ and $\cat{B} : \cat{D}\op \to
  \Cat{Cat}$ be strict indexed categories. A \emph{strict indexed functor}
  $(F, \overline{F}) : \cat{A} \to \cat{B}$ is a pair consisting of
  \begin{itemize}
  \item A functor $F : \cat{C} \to \cat{D}$, and
    \item A natural transformation $\overline{F} : \cat{A} \to \cat{B} \circ
      F\op$. Explicitly, this is a family of functors $\overline{F}_C :
      \cat{A}(C) \to \cat{B}(FC)$ so that for any $r : C' \to C$, we have that
      $\overline{F} \circ r^{\ast} = (Fr)^{\ast} \circ \overline{F}$.
\end{itemize}

If $\cat{A}$ and $\cat{B}$ are monoidal strict indexed categories, then an
indexed functor $(F, \overline{F}) : \cat{A} \to \cat{B}$ is strict monoidal if
$F(C_1 \otimes C_2) = FC_1 \otimes FC_2$ and $\overline{F}(A_1 \boxtimes A_2) =
\overline{F}(A_1) \boxtimes \overline{F}(A_2)$, and $F$ and $\overline{F}$ send
associators to associators and unitors to unitors.
\end{definition}

\begin{proposition}\label{prop.functoriality_monoidal_groth}
  Let $(F, \overline{F}) : \cat{A} \to \cat{B}$ be a strict indexed functor.
  Then there is a functor 
\[
\lens{\overline{F}}{F} : \int^{C : \cat{C}}\cat{A}(C) \to \int^{D : \cat{D}}\cat{B}(D)
\]
given by
$$\lens{\overline{F}}{F}\lens{f_{\flat}}{f} \coloneqq
\lens{\overline{F}f_{\flat}}{Ff}.$$ 

If furthermore $(F, \overline{F})$ is strictly monoidal, then so is $\lens{\overline{F}}{F}$.
\end{proposition}
\begin{proof}
We will show that this assignment is functorial. Recall that 
\[
\lens{f_{\flat}}{f} \then \lens{g_{\flat}}{g} \coloneqq \lens{f_{\flat} \then
  f^{\ast}g_{\flat}}{f \then g}.
\]
We may therefore calculate:
\begin{align*}
\lens{\overline{F}}{F}\left(\lens{f_{\flat}}{f} \then \lens{g_{\flat}}{g}  \right) &= \lens{\overline{F}(f_{\flat} \then f^{\ast}g_{\flat})}{F(f \then g)}\\
&= \lens{\overline{F}f_{\flat}\then \overline{F}(f^{\ast}g_{\flat})}{Ff \then Fg}\\
&= \lens{\overline{F}f_{\flat} \then (Ff)^{\ast}(\overline{F}g_{\flat})}{Ff \then Fg}\\
&= \lens{\overline{F}}{F}\lens{f_{\flat}}{f} \then \lens{\overline{F}}{F}\lens{g_{\flat}}{g}
\end{align*}
We end by noting that $\lens{\overline{F}}{F}\lens{\id}{\id} = \lens{\id}{\id}$
by functoriality of $F$ and $\overline{F}$.

If $(F, \overline{F})$ is strictly monoidal, then so is $\lens{\overline{F}}{F}$
because the monoidal structure of the Grothendieck constructions are defined by
pairing the monoidal structures of the base.
\end{proof}

\begin{proposition}\label{prop.commutative_monad_indexed_functor}
  Let $\phi : M \to N$ be a commutative monad morphism. Then there is a strict
  monoidal indexed functor
  $$(\id, \phi_{\ast}) : \smctx{-}^M \to \smctx{-}^N.$$
\end{proposition}
\begin{proof}
We need to give a family of strict monoidal functors $\phi_{\ast} : \smctx{C}^M \to
\smctx{C}^N$, natural in $C$. We take $\phi_{\ast}$ to act as the identity on
objects, and for $f : C \times X \to MY$, we define 
$$\phi_{\ast} f \coloneqq f \then \phi.$$
We now show that this is functorial using the do notation:
\begin{align*}
  \phi_{\ast}(f \then g) &= f \then g \then \phi \\
&= (c, x) \mapsto \phi\left( \, \unalignedDo{
          ${y \from f(c, x)}$,
          ${g(c, y)}$
 }\,\right) \\
  &= (c , x) \mapsto \unalignedDo{
    ${y \from \phi(f(c, x))}$,
    ${\phi(g(c, y))}$
    }&\mbox{by \cref{lem.com_monad_map_lift}}\\
&= \phi_{\ast}f \then \phi_{\ast}g.
\end{align*}
We also note that $\phi_{\ast} \id = \id$ since 
\begin{align*}
\phi_{\ast}(\id) = \pi_2 \then \eta^M \then \phi \\
&= \pi_2 \then \eta^N\\
&= \id
\end{align*}

We may also use the do notation to prove strict monoidal-ness. We begin by
noting that the functor is strictly monoidal on objects since it is identity on
objects and the monoidal structures are defined identically.
\begin{align*}
  \phi_{\ast}(f \otimes g) &= (c, x_1, x_2) \mapsto \phi\left( \, \unalignedDo{
                             ${y_1 \from f(c, x_1)}$,
${y_2 \from g(c, x_2)}$,
${\eta^M(y_1, y_2)}$
                             } \,  \right) \\
&= \unalignedDo{
                             ${y_1 \from \phi(f(c, x_1))}$,
${y_2 \from \phi(g(c, x_2))}$,
${\phi\eta^M(y_1, y_2)}$
                             }\\
&= \unalignedDo{
                             ${y_1 \from \phi(f(c, x_1))}$,
${y_2 \from \phi(g(c, x_2))}$,
${\eta^N(y_1, y_2)}$
                             } \\
&= \phi_{\ast}f \otimes \phi_{\ast}g.
\end{align*}

\end{proof}

\begin{corollary}
  Let $\phi : M \to N$ be a commutative monad morphism. Then there is a strict
  monoidal functor 
$$\phi_{\ast} : \Cat{Lens}_{\cat{C}}^M \to \Cat{Lens}_{\cat{C}}^N$$
Given by 
$$\phi_{\ast} \lens{f^{\sharp}}{f} \coloneqq \lens{f^{\sharp} \then \phi}{f}.$$
\end{corollary}
\begin{proof}
We may apply \cref{prop.functoriality_monoidal_groth} to
\cref{prop.commutative_monad_indexed_functor} (or, more precisely, to the
pointwise opposite $(\id, \phi_{\ast}\op)$).
\end{proof}

The theorem has a useful corollary: we can always wire together
non-deterministic systems with wiring diagrams.
\begin{corollary}
  For any commutative monad $M : \cat{C} \to \cat{C}$, there is a strictly
  monoidal functor 
$$\eta_{\ast} : \Cat{Lens}_{\cat{C}} \to \Cat{Lens}_{\cat{C}}^M.$$ 
\end{corollary}

\begin{example}

Suppose we have two people $\Sys{S_1}$ and $\Sys{S_2}$ flipping coins.
$\Sys{S_1}$ flips a single fair coin and exposes its value:
  \[
\begin{tikzpicture}[oriented WD, every fit/.style={inner xsep=\bbx, inner ysep=\bby}, bbx = 1cm, bby =.5cm, bb min width=1cm, bb port length=4pt, bb port sep=1, baseline=(X.center)]
	\node[bb={0}{1}, fill=blue!10] (X) {$\Sys{\Sys{S_1}}$};
	\draw[label] 
		node [right=2pt of X_out1] {$\{\const{heads}, \const{tails}\}$}
		;
\end{tikzpicture}
  \]
  That is, $\State{S_1} = \{\const{heads}, \const{tails}\}$
  \begin{align*}
 \update{S_1}(\_) &= \frac{1}{2}\const{heads} + \frac{1}{2} \const{tails}\\
 \expose{S_1} &= \id.
\end{align*}
On the other hand, $\Sys{S_2}$ will flip either a left coin or a right coin, and
expose the resulting value. But these coins are biased in different ways The coin that $\Sys{S_2}$ flips is determined by
whether it sees $\const{heads}$ or $\const{tails}$.
  \[
\begin{tikzpicture}[oriented WD, every fit/.style={inner xsep=\bbx, inner ysep=\bby}, bbx = 1cm, bby =.5cm, bb min width=1cm, bb port length=4pt, bb port sep=1, baseline=(X.center)]
	\node[bb={1}{1}, fill=blue!10] (X) {$\Sys{S_2}$};
	\draw[label] 
		node [right=2pt of X_out1] {$\{\const{heads}, \const{tails}\}$}
		;
\end{tikzpicture}
  \]
  That is, $\State{S_1} = \{\const{heads}, \const{tails}\}$ and
  \begin{align*}
\update{S_2}(\_, \const{heads}) &= \frac{1}{4}\const{heads} + \frac{3}{4}\const{tails}\\
\update{S_2}(\_, \const{tails}) &= \frac{3}{4}\const{heads} + \frac{1}{4}\const{tails}\\
\expose{S_2} &= \id.
    \end{align*}
We can now imagine that $\Sys{S_1}$ sends the result of their coin flip over a
channel to $\Sys{S_2}$. But this channel has noise given by 
\begin{align*}
  \rho(\const{heads}) &= \frac{9}{10}\const{heads} + \frac{1}{10}\const{tails} \\
  \rho(\const{tails}) &= \frac{1}{10}\const{heads} + \frac{9}{10}\const{tails} 
\end{align*}

Explictly, we will compose with the wiring diagram:
\[
\begin{tikzpicture}[oriented WD, every fit/.style={inner xsep=\bbx, inner ysep=\bby}, bbx = 1cm, bby =.5cm, bb min width=1cm, bb port length=0pt, bb port sep=1, baseline=(X.center)]
	\node[bb={0}{1}, fill=blue!10, dashed] (X) {$\phantom{\Sys{Source}}$};
  \node[draw=dgreen,circle, right = of X] (n) {$\rho$};
	\node[bb={1}{1}, fill=blue!10, right = of n, dashed] (Y) {$\phantom{\Sys{Transformer}}$};
  \node[bb={0}{1}, fit={(X) (Y)}] (Z) {};


  \draw (X_out1) -- (n) -- (Y_in1);
  \draw (Y_out1) -- (Z_out1);
  

	\draw[label] 
		node at ($(X_out1) + (5pt, 5pt)$) {$A$}
		node at ($(Y_out1) + (5pt, 5pt)$) {$C$}
		node at ($(Y_in1) + (-5pt, 5pt)$) {$B$}
		;
\end{tikzpicture}
\]
We can describe this as a $\probset$-lens 
\[
\lens{w^{\sharp}}{w} : \lens{\In{S_1} \times \In{S_2}}{\Out{S_1} \times
  \Out{S_2}} \fromto \lens{\{\ast\}}{\Out{S_2}}
\]
\begin{itemize}
\item $w : \Out{S_1} \times \Out{S_2} \to \Out{S_2}$ is the projection $\pi_2$.
\item $w^{\sharp}: \Out{S_1} \times \Out{S_2} \times \{\ast\} 
  \to \probset ( \In{S_1} \times \In{S_2} )$ is given by 
$$w^{\sharp}(x, y, \ast) = (\ast, \rho(x)).$$
\end{itemize}

We may now form the composite system:
\[
\begin{tikzpicture}[oriented WD, every fit/.style={inner xsep=\bbx, inner ysep=\bby}, bbx = 1cm, bby =.5cm, bb min width=1cm, bb port length=0pt, bb port sep=1, baseline=(X.center)]
	\node[bb={0}{1}, fill=blue!10] (X) {$\Sys{S_1}$};
  \node[draw=dgreen,circle, right = of X] (n) {$\rho$};
	\node[bb={1}{1}, fill=blue!10, right = of n] (Y) {$\Sys{S_2}$};
  \node[bb={0}{1}, fit={(X) (Y)}] (Z) {};

  \draw (X_out1) -- (n) -- (Y_in1);
  \draw (Y_out1) -- (Z_out1);
\end{tikzpicture}
\]
This has states $\State{S_1} \times \State{S_2}$, exposes just the state of
$\State{S_2}$, and updates in the following way:
\begin{align*}
 \update{}((\_, \_), \ast) = \begin{aligned}
   &\hphantom{+} \frac{1}{2}\left( \frac{9}{10}\frac{1}{4} + \frac{1}{10}\frac{3}{4} \right)(\const{heads}, \const{heads}) \\
&+\frac{1}{2}\left( \frac{1}{10}\frac{3}{4} + \frac{9}{10}\frac{1}{4} \right)(\const{tails}, \const{heads})\\
 &+\frac{1}{2}\left( \frac{9}{10}\frac{3}{4} + \frac{1}{10}\frac{1}{4} \right)(\const{heads}, \const{tails})\\
 &+\frac{1}{2}\left( \frac{1}{10}\frac{3}{4} + \frac{9}{10}\frac{1}{4} \right)(\const{tails}, \const{tails})\\
\end{aligned}\\
\end{align*}


\end{example}

\section{Summary and Further Reading}

In this chapter, we extended the notion of lens to monadic lenses to accomodate
non-deterministic systems. We saw how any commutative monad gave rise to a
doctrine of non-determinism, from possibilistic to probabilistic to costs and
rewards. One nice thing about monads is that you can play with them in Haskell.
There are plenty of places to learn about monads in Haskell (perhaps too many),
so I won't make any specific recommendations. For more about monads in category
theory, check out Chapter 5 of \cite{perrone2021notes}.

We then saw how the notion of lens could be generalized to any indexed category.
This notion of generalized lens is due to Spivak in
\cite{spivak2019generalized}. This generalization of lens will underly our
formal notion of dynamical system doctrine, which will be introduced in the
next chapter. 

\end{document}



 
%% Local Variables:
%% End: