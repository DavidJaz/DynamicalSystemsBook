\documentclass[DynamicalBook]{subfiles}
\begin{document}
%


\setcounter{chapter}{5}%Just finished 5.


%------------ Chapter ------------%
\chapter{Data dynamics}\label{chapter.6} 

%-------- Section --------%
\section{Introduction}\label{sec.c6_intro}

%Old "pattern" stuff moved to after end document.

In the previous chapter we saw that comonoids in $\poly$ are categories, but that morphisms of comonoids are not functors; they're called cofunctors. If someone were to ask ``which are better, functors or cofunctors'', the answer is clear. Functors are fundamental to mathematics itself, relating branches from set theory to logic to algebra to measure theory, etc. Cofunctors don't have anywhere near that sort of reach in terms of applicability. Still they provide an interesting way to compare categories, as well as new invariants of categories, like the monoid of direction fields on a category.

In this chapter we'll consider another kind of morphism between comonoids in $\poly$, i.e.\ categories, and one that is a bit more familiar than cofunctors. Namely, we'll consider the bimodules between comonoids. One might want to call them bi-co-modules, but this name is just a bit too long and the name bimodule is not ambiguous, so we'll go with it. So why do I say they're more familiar?

It turns out that bimodules between comonoids in $\poly$ (categories) are also important objects of study in category theory. If $\cat{C}$ and $\cat{D}$ are categories, Richard Garner showed that a bimodule between them can be identified with what's known as a \emph{parametric right adjoint} between the associated copresheaf categories $\cat{C}\set$ and $\cat{D}\set$. Parametric right adjoints, or \emph{pra}'s come up in $\infty$-category theory, but they also have a much more practical usage: they are the so-called \emph{data migration functors}.

Indeed, we'll make due on a claim we made in \cref{chapter.4}, that there is a strong connection between the basic theory of databases and the theory of bimodules in $\poly$. Databases have two parts: they have a schema, a specification of various types and relationships between them, and an instance, which is actual data sorted into those types and having those relationships. As we'll see, one can formalize the schema as a category $\cat{C}$ and the instance as a functor $I\colon\cat{C}\to\smset$. Here's an example of a theorem we'll prove:

\begin{theorem}\label{thm.tfae_c_sets}
For a comonoid $\com{C}=(\ema{c},\epsilon,\delta)$, also understood as a category $\cat{C}$, the following categories are equivalent:
\begin{enumerate}
	\item functors $\cat{C}\to\smset$;
	\item discrete opfibrations over $\cat{C}$;
	\item cartesian cofunctors to $\com{C}$;
	\item linear left $\com{C}$-modules;
	\item constant left $\com{C}$-modules;
	\item $(\com{C},0)$-bimodules;
	\item representable right $\com{C}$-modules;
	\item $\com{C}$-coalgebras (sets with a coaction by $\com{C}$).
\end{enumerate}
Moreover, up to isomorphism, a $\com{C}$-coalgebra can be identified with a dynamical system with comonoid interface $\com{C}$.
\end{theorem}
The proof will be given in \cref{thm.tfae_c_sets}.

The plan of the chapter is as follows. We'll begin in \cref{sec.copresheaves_data_ds} by reviewing copresheaves on a category, and their relationship to databases and dynamical systems. Then in \cref{sec.bimodules} we'll prove a number of theoretical results, including \cref{thm.tfae_c_sets} and Garner's ``bimodules are parametric right adjoints'' result. We'll continue to give intuition and applications in database and dynamical systems theory. Finally in \cref{sec.discussion_open_qs} we'll provide some looser discussion and lay out some open questions.

%-------- Section --------%
\section{Copresheaves, databases, and dynamical systems}\label{sec.copresheaves_data_ds}

Let $\cat{C}$ be a small category. One of the most important constructions in category theory is that of the category of copresheaves on $\cat{C}$.%
\footnote{Many would say that presheaves on $\cat{C}$ are more fundamental, but since the notions are equivalent---just use $\cat{C}\op$ to switch between them---we will consider the difference moot. We will focus on copresheaves.}
This is the category
\[
\cat{C}\set\coloneqq\Cat{Fun}(\cat{C},\smset)
\]
whose objects are functors $\cat{C}\to\smset$ and whose morphisms are natural transformations between them.

\begin{example}
Suppose $(G,e,*)$ is a monoid (e.g.\ a group). In a first course on abstract algebra, one encounters the notion of a \emph{$G$-set}, which is a set $X$ together with a $G$ action: for every element $g\in G$ we get a function $\alpha_g\colon X\to X$; we might write $\alpha_g(x)$ as $g\cdot x$. To be a $G$-action, the $\cdot$ operation needs to satisfy two rules: $e\cdot x=x$ and $g\cdot(h\cdot x)=(g*h)\cdot x$. A morphism between two $G$-sets (sets $X$ and $Y$, each equipped with a $G$-action) is just a function $f\colon X\to Y$ that  satisfies a single rule: $f(g\cdot x)=g\cdot (f(x))$ for all $g\in G$ and $x\in X$.

Now recall that any monoid (e.g.\ a group) $G$ can be understood as a category with one object, let's call our category $\cat{G}$ and the unique object $\blacktriangle$. The elements of $G$, including the identity and the multiplication, are encoded as the morphisms $\blacktriangle\to\blacktriangle$ in $\cat{G}$. 

It turns out that $G$-sets are precisely functors $F\colon\cat{G}\to\smset$: the set $F(\blacktriangle)$ is our $X$ above, and since the elements of $G$ are now morphisms $g\colon \blacktriangle\to\blacktriangle$, the functor $F$ sends them to functions $F(g)\colon X\to X$; this is the $g\cdot-$ operation. The axioms of a functor---preservation of identities and compositions---ensure the two rules of the $\cdot$ operation. Finally, morphisms between $G$-sets are exactly the natural transformations between functors; the naturality condition becomes the rule $f(g\cdot x)=g\cdot (f(x))$ we saw above.

\slogan{$G$-sets are copresheaves on the associated one-object category $\cat{G}$.}
\end{example}

\begin{example}[Clue game]\label{ex.clue_game}
There is a game that is played in the US, called Clue, where each players is a detective trying to solve a murder mystery. The game consists of a board together with a deck of several cards, and on each card there is both some printed words and a picture. For one card, the words might say ``Ms.\ White'' and the picture shows a woman; for another card, the words might say ``knife'' and the picture shows a knife. Every card has a type: it is either a room card, a weapon card, or a person card; e.g.\ the Ms.\ White card is a person card and the knife card is a weapon card.

Now consider the commutative square category whose objects are labeled as follows:
\[
\Cat{Sq}\coloneqq\boxCD{examplecolor}{
\begin{tikzcd}[sep=large, ampersand replacement=\&]
	\LTO{Card}\ar[r, "\text{has picture}"]\ar[d, "\text{has word}"']\&[10pt]
	\LTO{Picture}\ar[d, "\text{has type}"]\\
	\LTO{Word}\ar[r, "\text{has type}"']\&
	\LTO{Type}
	\ar[ul, phantom, "\checkmark"]
\end{tikzcd}
}
\]
A functor $D\colon\Cat{Sq}\to\smset$ would be a possible Clue deck: a set of cards, each of which has an associated picture, some associated words, and the words and picture both have the same type (e.g.\ room, weapon, person, whatever). Of course, a priori, $D$ is just a commutative square of sets and functions, but we'll refer to elements of $D(\text{Card})$ as cards, etc.

Here we will give our own version of the game and use it to illustrate databases. It will be a running example throughout the chapter. We start with a functor $\deck\colon\Cat{Sq}\to\smset$, written as a database instance with schema $\Cat{Sq}$:
\begin{equation}\label{eqn.clue_database_instance}
\begin{gathered}
\begin{array}{| l || l | l | l |}
	\bhline
  \multicolumn{4}{| c |}{\text{Deck Card}}\\\bhline
  \textbf{Card}&\textbf{has word}&\textbf{has picture}&\textbf{has type}\\\bbhline
  W&\text{White}&\circ&\text{Color}\\\hline
  B&\text{Black}&\bullet&\text{Color}\\\hline
  C&\text{Circle}&O&\text{Object}\\\hline
  T&\text{Table}&\Pi&\text{Object}\\\hline
  P&\text{Person}&\tikzsymStrichmaxerl[1.2]&\text{Object}\\\hline
  H&\text{Here}&\cdot&\text{Place}\\\hline
  U&\text{Up}&\uparrow&\text{Place}\\\hline
  D&\text{Down}&\downarrow&\text{Place}\\\hline
  L&\text{Left}&\leftarrow&\text{Place}\\\hline
  R&\text{Right}&\rightarrow&\text{Place}\\\bhline
\end{array}
\\~\\
\footnotesize
\begin{array}{| l || l |}
  \bhline
  \multicolumn{2}{| c |}{\text{Deck Picture}}\\\bhline
  \textbf{Picture}&\textbf{has type}\\\bbhline
  \circ&\text{Color}\\\hline
  \bullet&\text{Color}\\\hline
  O&\text{Object}\\\hline
  \Pi&\text{Object}\\\hline
  \tikzsymStrichmaxerl[1.2]&\text{Object}\\\hline
  \cdot&\text{Place}\\\hline
  \uparrow&\text{Place}\\\hline
  \downarrow&\text{Place}\\\hline
  \leftarrow&\text{Place}\\\hline
  \rightarrow&\text{Place}\\\bhline
\end{array}
\hspace{.5in}
\begin{array}{| l || l |}
  \bhline
  \multicolumn{2}{| c |}{\text{Deck Word}}\\\bhline
  \textbf{Word}&\textbf{has type}\\\bbhline
  \text{White}&\text{Color}\\\hline
  \text{Black}&\text{Color}\\\hline
  \text{Circle}&\text{Object}\\\hline
  \text{Table}&\text{Object}\\\hline
  \text{Person}&\text{Object}\\\hline
  \text{Here}&\text{Place}\\\hline
  \text{Up}&\text{Place}\\\hline
  \text{Down}&\text{Place}\\\hline
  \text{Left}&\text{Place}\\\hline
  \text{Right}&\text{Place}\\\bhline
\end{array}
\hspace{.5in}
\begin{array}{| l ||}
  \bhline
  \multicolumn{1}{| c |}{\text{Deck Type}}\\\bhline
  \textbf{Type}\\\bbhline
	\text{Color}\\\hline
  \text{Object}\\\hline
  \text{Place}\\\bhline
\end{array}
\end{gathered}
\end{equation}
\end{example}


\begin{exercise}
\begin{enumerate}
  \item With the instance $\Fun{Deck}\colon\Cat{Sq}\to\smset$, what set is $\Fun{Deck}(\text{Card})$?
  \item What set is $\Fun{Deck}(\text{Word})$?
  \item What is the function $\Fun{Deck}(\text{has word})\colon\Fun{Deck}(\text{Card})\to\Fun{Deck}(\text{Card})$?
	\item Do you think there is anything mathematically-special about the database instance presented in \cref{ex.clue_game}? That is, as a functor $\Cat{Sq}\to\smset$, does it seem relatively generic, or does something about it seem special?
	\item If you'd say it's not special, why not? If you'd say it is special, give another instance (functor $\Cat{Sq}\to\smset$, written in database form) that is not special in this way. 
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}
Continuing with \cref{ex.clue_game}, we again consider the commutative square category 
\[
\Cat{Sq}=
\begin{tikzcd}[sep=small, ampersand replacement=\&]
	\LTO{Card}\ar[r]\ar[d]\&[10pt]
	\LTO{Picture}\ar[d]\\
	\LTO{Word}\ar[r]\&
	\LTO{Type}
	\ar[ul, phantom, "\checkmark"]
\end{tikzcd}
\]
Let $P\coloneqq\{b,w\}^{\ord{100}\times\ord{100}}$ be a set whose elements we call (black and white) pictures, let $W\coloneqq\List(\{\text{A,a},\ldots,\text{Z,z}\})$ be a set whose elements we call words, and let $T\coloneqq\{\text{Color,Object,Place}\}$ be a set whose elements we call types. We can thus create a database instance $J\colon\Cat{Sq}\to\smset$ sending
\[
  J(\text{Type})\coloneq T,\quad
  J(\text{Word})\coloneqq W\times T,\quad
  J(\text{Picture})\coloneqq P\times T,\quad
  J(\text{Card})\coloneqq P\times W\times T
\]
with the maps in $\Cat{Sq}$ sent to the evident product projections. We will later see in \cref{**} where these products and projections come from.

For now, we again consider our clue game. If we want to think of our pictures, e.g.\ $\tikzsymStrichmaxerl[1.2]$, really as pictures or our words, e.g.\ ``Person'', really as words, then we need to be given a map of database instances---a natural transformation---of the form $\tau\colon\Fun{Deck}\to J$. In particular, $\tau$ assigns every card in the deck a word, a picture, and a type.
\end{example}

\begin{definition}[Discrete opfibration]\label{def.dopf}
Let $\cat{C}$ be a category. A pair $(\cat{S},\pi)$, where $\cat{S}$ is a category and $\pi\colon\cat{S}\to\cat{C}$ is a functor, is called a \emph{discrete opfibration over $\cat{C}$} if it satisfies the following condition.
\begin{itemize}
	\item for every object $s\in\cat{S}$, object $c'\in\cat{C}$, and morphism $f\colon \pi(s)\to c'$ there exists a unique object $s'\in\cat{S}$ and morphism $\bar{f}\colon s\to s'$ such that $\pi(s')=c'$ and $\pi(\bar{f})=f$.
\end{itemize}
\[
\begin{tikzcd}
  s\ar[r, dashed, "\bar{f}"]\ar[d, |->, "\pi"']&
  s'\ar[d, |->, "\pi"]\\
  \pi(s)\ar[r, "f"']&
  c'
\end{tikzcd}
\]
A \emph{morphism} $(\cat{S},\pi)\to(\cat{S}',\pi')$ between discrete opfibrations over $\cat{C}$ is a functor $F\colon\cat{S}\to\cat{S}'$ making the following triangle commute:
\begin{equation}\label{eqn.dopf_triangle}
\begin{tikzcd}[column sep=small]
	\cat{S}\ar[dr, "\pi"']\ar[rr, "F"]&&
	\cat{S}'\ar[dl, "\pi'"]\\&
	\cat{C}
\end{tikzcd}
\end{equation}
We denote the category of discrete opfibrations into $\cat{C}$ by $\Cat{dopf}(\cat{C})$.
\end{definition}

\begin{exercise}
Show that if $F\colon \cat{S}\to\cat{S}'$ is a functor making the triangle \eqref{eqn.dopf_triangle} commute, then $F$ is also a discrete opfibration. 
\end{exercise}

\begin{exercise}\label{exc.dopf_cof}
Suppose $\pi\colon\cat{S}\to\cat{C}$ is a discrete opfibration and $i\in\cat{S}
$ is an object. With notation as in \cref{def.dopf}, show the following:
\begin{enumerate}
	\item Show that the lift $\bar{\id_{\pi(i)}}=\id_i$ of the identity on $\pi(i)$ is the identity on $i$.
	\item Show that for $f\colon\pi(i)\to c$ and $g\colon c\to c'$, we have $\bar{f}\then\bar{g}=\bar{f\then g}$.
	\item Show that $\pi$ is a cofunctor.
\qedhere
\end{enumerate}
\end{exercise}

\begin{definition}[Category of elements $\int^\cat{C}I$]\label{def.cat_elements}
Given a functor $I\colon\cat{C}\to\smset$, its category of elements $\int^\cat{C}I$ is defined to have objects
\[
\Ob(\int^\cat{C}I)\coloneqq\{(c,x)\mid c\in\Ob(\cat{C}), x\in I(c)\}
\]
and given two objects $(c,x)$ and $(c',x')$, the hom-set is given by
\[
\Hom((c,x),(c',x'))\coloneqq\{f\colon c\to c'\mid I(f)(x)=x'\}.
\]
Identities and composites in $(\int^\cat{C}I)$ are inherited from $\cat{C}$.

There is a functor $\pi\colon(\int^\cat{C}I)\to\cat{C}$ sending $\pi(c,x)\coloneqq c$ and $\pi(f)\coloneqq f$.
\end{definition}

\begin{exercise}
Show that if $I\colon\cat{C}\to\smset$ is a functor then the functor $\pi\colon(\int^\cat{C}I)\to\cat{C}$ defined in \cref{def.cat_elements} is a discrete opfibration, as in \cref{def.dopf}.
\end{exercise}

\begin{exercise}\label{exc.elts_functor}
Suppose that $I,J\colon\cat{C}\to\smset$ are functors and $\alpha\colon I\to J$ is a natural transformation. 
\begin{enumerate}
	\item Show that $\alpha$ induces a functor $(\int^\cat{C}I)\to(\int^\cat{C}J)$.
	\item Show that it is a morphism of discrete opfibrations in the sense of \cref{def.dopf}.
	\item Show that this construction is functorial. We denote this functor by
\end{enumerate}
	\[
	\int^\cat{C}\colon\cat{C}\set\to\Cat{dopf}(\cat{C})
\qedhere	
	\]
\end{exercise}


\begin{proposition}
Let $\cat{C}$ be a category. The following are equivalent:
\begin{enumerate}
	\item the category $\cat{C}\set$ of functors $\cat{C}\to\smset$,
	\item the category of discrete opfibrations over $\cat{C}$,
	\item the category of cartesian cofunctors into $\cat{C}$.
\end{enumerate}
\end{proposition}
\begin{proof}
By \cref{exc.elts_functor} we have a functor $\int^\cat{C}\colon\cat{C}\set\to\Cat{dopf}(\cat{C})$. There is a functor going back: given a discrete opfibration $\pi\colon\cat{S}\to\cat{C}$, we define $(\partial\pi)\colon\cat{C}\to\smset$ on $c\in\Ob(\cat{C})$ and $f\colon c\to c'$ by 
\begin{align*}
	(\partial\pi)(c)&\coloneqq\{s\in\cat{S}\mid\pi(s)=c\}\\
	(\partial\pi)(f)(s)&\coloneqq\bar{f}(s).
\end{align*}
On objects, the roundtrip $\cat{C}\set\to\cat{C}\set$ sends $I\colon\cat{C}\to\smset$ to the functor
\begin{align*}
	c&
	\mapsto\{s\in\int^\cat{C}I\mid \pi(s)\\&
	=\{(c,x)\mid x\in I(c)\}&=I(c).
\end{align*}
The roundtrip $\Cat{dopf}(\cat{C})\to\Cat{dopf}(\cat{C})$ sends $\pi\colon\cat{S}\to\cat{C}$ to the discrete opfibration whose object set is $\{(c,s)\in\Ob(\cat{C})\times\Ob(\cat{S})\mid\pi(s)=c\}$ and this set is clearly in bijection with $\Ob(\cat{S})$. Proceeding similarly, one defines an isomorphism of categories $\cat{S}\cong\int^\cat{C}\partial\pi$.

The above correspondence is well-known; it remains to address the relationship between (2) and (3). FILL
\end{proof}


Recall from \cref{**} that a dynamical system on a category $\cat{C}$ consists of a set $S$ and a cofunctor $S\yon^S\cof\cat{C}$ from the state category on $S$ to $\cat{C}$.

\begin{proposition}[Database states are dynamical systems]\label{prop.ds_dopf}
Up to isomorphism, discrete opfibrations into $\cat{C}$ can be identified with dynamical systems on $\cat{C}$.
\end{proposition}
In case it isn't clear, this association is only functorial on the groupoid of objects and isomorphisms.
\begin{proof}
Given a discrete opfibration $\pi\colon\cat{S}\to\cat{C}$, take $S\coloneqq\Ob(\cat{S})$ and define $(\varphi_1,\varphi^\sharp)\colon S\yon^S\to\ema{c}$ by $\varphi_1=\pi$ and with $\varphi^\sharp$ given by the lifting: $\varphi(g)\coloneqq \hat{g}$ as in \cref{def.dopf}. One checks using \cref{exc.dopf_cof} that this defines a cofunctor. 

Conversely, given a cofunctor $(\varphi_1,\varphi^\sharp)\colon S\yon^S\to\ema{c}$, the function $\varphi_1$ induces a map of polynomials $S\yon\to\ema{c}$, and we can factor it as a vertical followed by a cartesian $S\yon\to\ema{s}\To{\psi}\ema{c}$. We can give $\ema{s}$ the structure of a category such that $\psi$ is a cofunctor; see \cref{exc.ds_dopf}.
\end{proof}

\begin{exercise}\label{exc.ds_dopf}
With notation as in \cref{prop.ds_dopf}, complete the proof as follows.
\begin{enumerate}
	\item Check that $(\varphi,\varphi^\sharp)$ defined in the first paragraph is indeed a cofunctor.
	\item Find a comonoid structure on $\ema{s}$ such that $\psi$ is a cofunctor, as stated in the second paragraph. 
	\item Show that the two directions are inverse, up to isomorphism.
\qedhere
\end{enumerate}
\end{exercise}


%-------- Section --------%
\section{Bimodules}\label{sec.bimodules}

When a polynomial
\[
m\coloneqq\sum_{i\in m(\1)}\yon^{m[i]}
\]
is given the structure of a $(\cat{D},\cat{C})$-bimodule, the symbols in that formula are given a hidden special meaning:
\[
  m(\1)\in\cat{D}\set
  \qqand
	m[i]\in\cat{C}\set
\]
Thus $m(1)$ is a database instance on $\cat{D}$; in particular, each position in $i\in m(\1)$ is a row in that instance. And each $m[i]$ is a database instance on $\cat{C}$; in particular, each direction $d\in m[i]$ is a row in that instance.

Before we knew about bimodule structures, what we called positions and directions---and what we often think of as outputs and inputs of a system---were understood as each forming an ordinary set. In the presence of a bimodule structure, the positions $m(\1)$ have been organized into a $\cat{D}$-set and the directions $m[i]$ have been organized into a $\cat{C}$-set for each position $i$. We are listening for $\cat{C}$-sets and positioning ourselves in a $\cat{D}$-set.

\begin{definition}
**
\end{definition}
\[
\begin{tikzpicture}
	\node (p1) {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom, "$m$" left] (m) {};
  	\node[poly, right= of m.south, yshift=-1ex, "\tiny$D$" below] (D) {};
  	\node[poly, above=of D, "\tiny$m$" above] (mm) {};
  	\node[poly, cod, right= of D.south, yshift=-1ex, "$D$" right] (DD) {};
  	\node[poly, cod, above=of DD, "$m$" right] (mmm) {};
  	\node[poly, cod, above=of mmm, "$C$" right] (C) {};
%
		\draw (m_pos) to[first] (D_pos);
		\draw (D_dir) to[climb] (mm_pos);
		\draw (mm_dir) to[last] (m_dir);
		\draw[double] (D_pos) to[first] (DD_pos);
		\draw[double] (DD_dir) to[last] (D_dir);
		\draw[double] (mm_pos) to[first] (mmm_pos);
		\draw (mmm_dir) to[climb] (C_pos);
		\draw (C_dir) to[last] (mm_dir);
	\end{tikzpicture}
	};
%
	\node (p2) [below=of p1] {
  \begin{tikzpicture}[polybox, tos]
  	\node[poly, dom, "$m$" left] (m') {};
  	\node[poly, right= of m'.south, yshift=-1ex, "\tiny$m$" below] (mm') {};
  	\node[poly, above=of mm', "\tiny$C$" above] (C') {};
  	\node[poly, cod, right= of mm'.south, yshift=-1ex, "$D$" right] (D') {};
  	\node[poly, cod, above=of D', "$m$" right] (mmm') {};
  	\node[poly, cod, above=of mmm, "$C$" right] (CC') {};
%
		\draw[double] (m'_pos) to[first] (mm'_pos);
		\draw (mm'_dir) to[climb] (C'_pos);
		\draw (C'_dir) to[last] (m'_dir);
		\draw (mm'_pos) to[first] (D'_pos);
		\draw (D'_dir) to[climb] (mmm'_pos);
		\draw (mmm'_dir) to[last] (mm'_dir);
		\draw[double] (C'_pos) to[first] (CC'_pos);
		\draw[double] (CC'_dir) to[last] (C'_dir);
	\end{tikzpicture}
	};	
	\node at ($(p1.south)!.5!(p2.north)$) {$=$};
\end{tikzpicture}
\]

\[
\begin{tikzpicture}[polybox, tos]
	\node[poly, dom, "$m$" left] (m) {};
	\node[poly, cod, right=of m, "$m$" right] (mm) {};
	\node[poly, cod, above=of mm, "$C$" right] (C) {};
	\node[poly, cod, below=of mm, "$D$" right] (D) {};
%
	\draw (m_pos) to[out=0, in=180] (D_pos);
	\draw (D_dir) to[climb] (mm_pos);
	\draw (mm_dir) to[climb] (C_pos);
	\draw (C_dir) to[last] (m_dir);
\end{tikzpicture}
\]

Recall from \cref{prop.basechange} that for any function $f\colon A\to B$, we have a base-change functor $f^*\colon B\poly\to A\poly$ and a cartesian morphism $f^*p\to p$ for any polynomial $p$ and isomorphism $p(\1)\cong B$.

\begin{proposition}\label{prop.right_modules_as_sums}
Let $\com{C}=(\ema{c},\epsilon,\delta)$ be a comonoid and suppose that $\rho\colon m\to m\tri\ema{c}$ is a right $\com{C}$-module. Then for any set $A$ and function $f\colon A\to m\tri\1$, the polynomial $f^*m$ has an induced right module structure $\rho_f$ fitting into the commutative square below:
\[
\begin{tikzcd}
  f^*m\ar[d]\ar[r, "\rho_f"]&
  f^*m\tri\ema{c}\ar[d]\\
  m\ar[r, "\rho"']&
  m\tri\ema{c}
\end{tikzcd}
\]
\end{proposition}
\begin{proof}
The pullback diagram to the left defines $f^*(m)$ and that to the right is its composition with $\ema{c}$
\[
\begin{tikzcd}
	f^*m\ar[r]\ar[d]&
	m\ar[d]\\
	A\ar[r, "f"']&
	m\tri\1\ar[ul, phantom, very near end, "\lrcorner"]
\end{tikzcd}
\hspace{.7in}
\begin{tikzcd}
	f^*m\tri\ema{c}\ar[r]\ar[d]&
	m\tri\ema{c}\ar[d]\\
	A\ar[r, "f"']&
	m\tri\1\ar[ul, phantom, very near end, "\lrcorner"]
\end{tikzcd}
\]
which is again a pullback by \cref{thm.connected_limits,exc.composing_with_constants}. Now the map $\rho\colon m\to m\tri\ema{c}$ induces a map $\rho_f\colon f^*(m)\to f^*(m)\tri c$; we claim it is a right module. It suffices to check that $\rho_f$ interacts properly with $\epsilon$ and $\delta$, which we leave to \cref{exc.right_modules_as_sums}.
\end{proof}

\begin{exercise}\label{exc.right_modules_as_sums}
Let $\ema{c},\epsilon,\delta)$, $\rho\colon m\to m\tri\ema{c}$, and $f\colon A\to m\tri\1$ be as in \cref{prop.right_modules_as_sums}. Complete the proof of that proposition as follows:
\begin{enumerate}
	\item Show that $\rho_f\then\epsilon=\id_m$
	\item Show that $\rho_f\then(f^*m\tri\delta)=\rho_f\then(\rho_f\tri\ema{c})$.
\qedhere
\end{enumerate}
\end{exercise}


\begin{theorem}\label{thm.tfae_c_sets}
For a comonoid $\com{C}=(\ema{c},\epsilon,\delta)$ (category $\cat{C}$), the following are equivalent:
\begin{enumerate}
	\item functors $\cat{C}\to\smset$
	\item discrete opfibrations over $\cat{C}$
	\item cartesian cofunctors to $\com{C}$
	\item linear left $\com{C}$-modules
	\item constant left $\com{C}$-modules
	\item $(\com{C},0)$-bimodules
	\item representable right $\com{C}$-modules
	\item $\com{C}$-coalgebras (sets with a coaction by $\com{C}$)
	\item dynamical systems with comonoid interface $\com{C}$
\end{enumerate}
\end{theorem}
\begin{proof}
\begin{description}
	\item[$1\to 2$:] Category of elements.
	\item[$2\to 1$:] Fibers.
\\	\item[$4\to 3$:] Given a linear left module, we can factor the underlying morphism $A\yon\to\ema{c}\tri A\yon$ as a vertical followed by a cartesian using \cref{prop.vert_cart_factorization}. The intermediate object has the structure of a category.
\end{description}
\end{proof}

Let $\cat{C}$ be a category. Under the above correspondence, the terminal functor $\cat{C}\to\smset$ corresponds to the identity discrete opfibration $\cat{C}\to\cat{C}$, the identity cofunctor $\com{C}\to\com{C}$, a certain left $\com{C}$ module with carrier $\com{C}(\1)\yon$ which we call the \emph{canonical left $\com{C}$-module}, a certain constant left $\com{C}$ module with carrier $\com{C}(\1)$ which we call the \emph{canonical $(\com{C},0)$-bimodule}, and a certain representable right $\com{C}$-module with carrier $\yon^{\com{C}(\1)}$ which we call the \emph{canonical right $\cat{C}$-module}.

\begin{exercise}
For any object $c\in \cat{C}$, consider the representable functor $\cat{C}(c,-)\colon\cat{C}\to\smset$. What does it correspond to as a
\begin{enumerate}
	\item discrete opfibration over $\cat{C}$?
	\item cartesian cofunctor to $\com{C}$?
	\item linear left $\com{C}$-module?
	\item constant left $\com{C}$-module?
	\item $(\com{C},0)$-bimodule?
	\item representable right $\com{C}$-module?
	\item dynamical system with comonoid interface $\com{C}$?
\qedhere
\end{enumerate}
\end{exercise}

\begin{example}\label{ex.clue_as_module}
We continue with the Clue game from \cref{ex.clue_game}. The database instance is encoded as:
\[
\left(
 \begin{array}{ccc}
 	10&&10\\
	&+\\
	10&&3
 \end{array}
\right)
\too
\left(
	\begin{array}{ccc}
		\left(
 		\begin{array}{ccc}
  		\1\0&&\1\0\\
  		&+\\
  		\1\0&&\3
   	\end{array}
		\right)^\4
		&&
		\left(
 		\begin{array}{ccc}
  		\1\0&&\1\0\\
  		&+\\
  		\1\0&&\3
   	\end{array}
		\right)^\2
		\\
		&+\\
		\left(
 		\begin{array}{ccc}
  		\1\0&&\1\0\\
  		&+\\
  		\1\0&&\3
   	\end{array}
		\right)^\2
		&&
		\left(
 		\begin{array}{ccc}
  		\1\0&&\1\0\\
  		&+\\
  		\1\0&&\3
   	\end{array}
		\right)^\1
  \end{array}
\right)
\]
Or if you prefer, $\3\3\to\3\3^\4+\3\3^\2+\3\3^\2+\3\3$.
\end{example}


\begin{proposition}\label{prop.all_free_modules}
Let $\com{C}=(\ema{c},\epsilon,\delta)$ be a comonoid in $\poly$. For any set $G$, the polynomial $\yon^G\tri\ema{c}$ has a natural right $\com{C}$-module structure.
\end{proposition}
\begin{proof}
We use the map $(\yon^G\tri\delta)\colon(\yon^G\tri\ema{c})\to(\yon^G\tri\ema{c}\tri\ema{c})$. It satisfies the unitality and associativity laws because $\ema{c}$ does.
\end{proof}

We can think of elements of $G$ as ``generators''. Then if $i'\colon G\to\ema{c}\tri\1$ assigns to every generator an object of a category $\cat{C}$, then we should be able to find the free $\cat{C}$-set that $i'$ generates.

\begin{proposition}
Functions $i'\colon G\to\ema{c}\tri\1$ are in bijection with positions $i\in\yon^G\tri\ema{c}\tri\1$. Let $m\coloneqq i^*(\yon^G\tri\ema{c})$ and let $\rho_i$ be the induced right $\com{C}$-module structure from \cref{prop.right_modules_as_sums}. Then $\rho_i$ corresponds to the free $\cat{C}$-set generated by $i'$. 
\end{proposition}
\begin{proof}
The polynomial $m$ has the following form:
\[
m\cong\yon^{\sum_{g\in G}\ema{c}[i'(g)]}
\]
In particular $\rho_i$ is a representable right $\com{C}$-module, and we can identify it with a $\cat{C}$-set by \cref{thm.tfae_c_sets}. The elements of this $\cat{C}$-set are pairs $(g, f)$, where $g\in G$ is a generator and $f\colon i'(g)\to\cod(f)$ is a morphism in $\cat{C}$ emanating from $i'(g)$. It is easy to see that the module structure induced by \cref{prop.all_free_modules} is indeed the free one.
\end{proof}


\begin{proposition}[Niu]
Let $\com{C}$ be a comonoid. The category of left $\com{C}$ modules is equivalent to the category of functors $\cat{C}\to\poly$.
\end{proposition}

\begin{proposition}
For any functor $F\colon\cat{C}\to\poly$, the limit polynomial $\lim_{c\in\cat{C}}F(c)$ is obtained by composing with the canonical right bimodule $\yon^{\Ob(\cat{C})}$
\[
\begin{tikzcd}
  \yon\ar[r,biml-bimr, "F"]\ar[rr, biml-bimr, bend right=20pt, "\lim F"']&
  \com{C}\ar[r,biml-bimr, "\yon^{\Ob(\cat{C})}"]&[5pt]
  \yon
\end{tikzcd}
\]
\end{proposition}

\begin{proposition}\label{prop.break_up_right_mods}
Let $\com{C}$ be a comonoid. For any set $I$ and right $\com{C}$-modules $(m_i)_{i\in I}$, the coproduct $m\coloneqq \sum_{i\in I}m_i$ has a natural right-module structure. Moreover, each representable summand in the carrier $m$ of a right $\com{C}$-module is itself a right-$\com{C}$ module and $m$ is their sum.
\end{proposition}
\begin{proof}
**
\end{proof}
%
%Let $\sum_{I\in\smset}\prod_{i\in I}\bimod{}{\com{C}}$ denote the category whose objects are pairs $(I,(m_i)_{i\in I})$ where $I$ is a set and $m_i$ is a right $\com{C}$-module for each $i\in I$. A morphism $(I,(m_i)_{i\in I})\to(J,(n_j)_{j\in J})$ is a function $f\colon I\to J$ and, for each $i\in I$ a morphism $m_i\to n_{f(i)}$ of right-$\com{C}$ modules.
%
%\begin{proposition}
%For any comonoid $\com{C}$ there is an adjunction
%\[
%\adj[40pt]{\bimod{}{\com{C}}}{\sum_{i\in I}m_i}{{(n(\1),n[-])}}{\sum_{I\in\smset}\prod_{i\in I}\bimod{}{\com{C}}}
%\]
%with functors labeled by where they send $n\in\bimod{}{\com{C}}$ and $(I,(m_i)_{i\in I})\in\sum_{I\in\smset}\prod_{i\in I}\bimod{}{\com{C}}$. 
%
%Moreover, the left adjoint is fully faithful.
%\end{proposition}

\begin{proposition}
If $m\in\poly$ is equipped with both a right $\com{C}$-module and a right $\com{D}$-module structure, we can naturally equip $m$ with a $(\com{C}\times\com{D})$-module structure.
\end{proposition}
\begin{proof}
It suffices by \cref{prop.break_up_right_mods} to assume that $m=\yon^M$ is representable. But a right $\com{C}$-module with carrier $\yon^M$ can be identified with a cofunctor $M\yon^M\to\com{C}$.

Thus if $\yon^M$ is both a right-$\com{C}$ module and a right-$\com{D}$ module, then we have comonoid morphisms $\com{C}\from M\yon^M\to\com{D}$. This induces a unique comonoid morphism $M\yon^M\to(\com{C}\times\com{D})$ to the product, and we identify it with a right-$(\com{C}\times\com{D})$ module on $\yon^M$.
\end{proof}


\subsection{Bimodules as data migration functors}


\begin{example}\label{ex.clue_suggestions}
We continue with the Clue game from \cref{ex.clue_game,ex.clue_as_module}. The database instance is encoded as a map
\[\3\3\to(\yon^\4+\2\yon^\2+\yon)\tri\3\3.\]
In this example we will first grab the three-element set of types, and then we'll make a new $\1\2$-element instance of the commutative square $\yon^\4+\2\yon^\2+\yon$ that copies that three-element set four times.

\[
\bullet
\bimodfrom[\yon]
\begin{tikzcd}[sep=small, ampersand replacement=\&]
	\bullet\ar[r]\ar[d]\&
	\bullet\ar[d]\\
	\bullet\ar[r]\&
	\bullet
	\ar[ul, phantom, "\tiny\checkmark"]
\end{tikzcd}
\bimodfrom[\3\3]\0
\]
The composite is the three-element set of types $\bullet\bimodfrom[\3]\0$, where here $\3$ is shorthand for $\{\text{Color,Object,Place}\}$. Now we can compose it with the ``copy-all'' map:
\[
\begin{tikzcd}[sep=small, ampersand replacement=\&]
	\bullet\ar[r]\ar[d]\&
	\bullet\ar[d]\\
	\bullet\ar[r]\&
	\bullet
	\ar[ul, phantom, "\tiny\checkmark"]
\end{tikzcd}
\bimodfrom[\4\yon]
\bullet
\bimodfrom[\3]\0
\]
The result is the following $\Cat{Sq}$-set:
\[
\begin{array}{| l || l | l | l |}
	\bhline
  \multicolumn{4}{| c |}{\text{Copy Types Deck Card}}\\\bhline
  \textbf{Card}&\textbf{has word}&\textbf{has picture}&\textbf{has type}\\\bbhline
  \text{Color}&\text{Color}&\text{Color}&\text{Color}\\\hline
  \text{Object}&\text{Object}&\text{Object}&\text{Object}\\\hline
  \text{Place}&\text{Place}&\text{Place}&\text{Place}\\\bhline
\end{array}
\]
\[\footnotesize
\begin{array}{| l || l |}
  \bhline
  \multicolumn{2}{| c |}{\text{Copy Types Deck Picture}}\\\bhline
  \textbf{Picture}&\textbf{has type}\\\bbhline
  \text{Color}&\text{Color}\\\hline
  \text{Object}&\text{Object}\\\hline
  \text{Place}&\text{Place}\\\hline
\end{array}
\hspace{.5in}
\begin{array}{| l || l |}
  \bhline
  \multicolumn{2}{| c |}{\text{Copy Types Deck Picture}}\\\bhline
  \textbf{Picture}&\textbf{has type}\\\bbhline
  \text{Color}&\text{Color}\\\hline
  \text{Object}&\text{Object}\\\hline
  \text{Place}&\text{Place}\\\hline
\end{array}
\hspace{.5in}
\begin{array}{| l ||}
  \bhline
  \multicolumn{1}{| c |}{\text{Copy Types Deck Type}}\\\bhline
  \textbf{Type}\\\bbhline
	\text{Color}\\\hline
  \text{Object}\\\hline
  \text{Place}\\\bhline
\end{array}
\]
Now why would we want to do this? The answer is that the maps of bimodules from this instance to the Deck are exactly what are called the \emph{suggestions} in the original Clue game. There are $\3\0$ of them:
\[
\left\{
\begin{array}{lllll}
  (\circ,O,\cdot),&
  (\circ,O,\uparrow),&
  (\circ,O,\downarrow),&
  (\circ,O,\from),&
  (\circ,O,\to),\\
%
  (\circ,\Pi,\cdot),&
  (\circ,\Pi,\uparrow),&
  (\circ,\Pi,\downarrow),&
  (\circ,\Pi,\from),&
  (\circ,\Pi,\to),\\
%
  (\circ,\tikzsymStrichmaxerl[1.2],\cdot),&
  (\circ,\tikzsymStrichmaxerl[1.2],\uparrow),&
  (\circ,\tikzsymStrichmaxerl[1.2],\downarrow),&
  (\circ,\tikzsymStrichmaxerl[1.2],\from),&
  (\circ,\tikzsymStrichmaxerl[1.2],\to),\\
%
  (\bullet,O,\cdot),&
  (\bullet,O,\uparrow),&
  (\bullet,O,\downarrow),&
  (\bullet,O,\from),&
  (\bullet,O,\to),\\
%
  (\bullet,\Pi,\cdot),&
  (\bullet,\Pi,\uparrow),&
  (\bullet,\Pi,\downarrow),&
  (\bullet,\Pi,\from),&
  (\bullet,\Pi,\to),\\
%
  (\bullet,\tikzsymStrichmaxerl[1.2],\cdot),&
  (\bullet,\tikzsymStrichmaxerl[1.2],\uparrow),&
  (\bullet,\tikzsymStrichmaxerl[1.2],\downarrow),&
  (\bullet,\tikzsymStrichmaxerl[1.2],\from),&
  (\bullet,\tikzsymStrichmaxerl[1.2],\to)
%
\end{array}
\right\}
\]
\end{example}

\begin{exercise}
Show that the $\3\3$-card deck from \cref{ex.clue_suggestions} factors---up to isomorphism---through a bimodule of the form $\yon^\4+\2\yon^\2+\yon\bimodfrom\yon^\2+\yon$, where $\yon^\2+\yon$ carries the walking arrow.
\end{exercise}

\subsection{Composing bimodules}

\begin{proposition}[Niu]\label{prop.composite_for_nats}
The composite of a linear left $\cat{C}$-module and a representable right $\cat{C}$-module is the set of natural transformations between the corresponding copresheaves.
\end{proposition}


\begin{example}
Using \cref{prop.composite_for_nats} we can obtain the $\3\0$ clue suggestions from \cref{ex.clue_suggestions} as a composite of bimodules.
(finish)
\end{example}

\section{The proarrow equipment}


%-------- Section --------%
\section{Discussion and open questions}\label{sec.discussion_open_qs}

In this section, we lay out some questions that whose answers may or may not be known, but which were not known to us at the time of writing. They vary from concrete to open-ended, they are not organized in any particular way, and are in no sense complete. Still we hope they may be useful to some readers.

\begin{enumerate}
  \item What can you say about the internal logic for the topos $\cofree{p}\smset$ of dynamical systems with interface $p$, in terms of $p$?
  \item How does the logic of the topos $\cofree{p}$ help us talk about issues that might be useful in studying dynamical systems?
  \item Morphisms $p\to q$ in $\poly$ give rise to left adjoints $\cofree{p}\to\cofree{q}$ that preserve connected limits. These are not geometric morphisms in general; in some sense they are worse and in some sense they are better. They are worse in that they do not preserve the terminal object, but they are better in that they preserve every connected limit not just finite ones. How do these left adjoints translate statements from the internal language of $p$ to that of $q$?
  \item Consider the $\times$-monoids and $\otimes$-monoids in three categories: $\poly$, $\smcat^\sharp$, and $\bimod{}{}$. Find examples of these comonoids, and perhaps characterize them or create a theory of them.
  \item Is there a functor $\poly$ has pullbacks, so one can consider the bicategory of spans in $\poly$. Is there a functor from that to $\bimod{}{}$ that sends $p\mapsto\cofree{p}$?
  \item Databases are static things, whereas dynamical systems are dynamic; yet we see them both in terms of $\poly$. How do they interact? Can a dynamical system read from or write to a database in any sense?
  \item Can we do database aggregation in a nice dynamic way?
  \item In the theory of polynomial functors, sums of representable functors $\smset\to\smset$, what happens if we replace sets with homotopy types: how much goes through? Is anything improved?
  \item Are there any functors $\smset\to\smset$ that aren't polynomial, but which admit a comonoid structure with respect to composition $(\yon,\tri)$?
  \item Characterize the monads in poly? They're generalizations of one-object operads (which are the Cartesian ones), but how can we think about them?
  \item Both functors and cofunctors give left adjoint bimodules: for functors $F\colon\cat{D}\to\cat{C}$ we use the pullback $\Delta_F$ and for cofunctors $G\colon\cat{C}\cof\cat{D}$ we use the companion as in \cref{**}. Can we characterize left adjoint bimodules in general?
  \item What limits exist in $\smcat^\sharp$? Describe them combinatorially.
  \item Since the forgetful functor $U\colon\smcat^\sharp\to\poly$ is faithful, it reflects monomorphisms: if $f\colon\cat{C}\cof\cat{D}$ is a cofunctor whose underlying map on emanation polynomials is monic, then it is monic. Are all monomorphisms in $\smcat^\sharp$ of this form?
  \item At first blush it appears that $\poly$ may be suitable as the semantics of a language for protocols. Develop such a language or showcase the limitations that make it impossible or inconvenient.
\end{enumerate}



\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
%\slogan{What is a pattern?}
%
%We are receptive to patterns; in fact we find that our thoughts are operating on them constantly. What patterns are you picking up on right now? Maybe you can stick with one or more of them as we try to tell a story about patterns in the abstract.
%
%Each pattern has a certain sort of shape---a certain repetitiveness---like the rational number
%\[\frac{1}{7}=.142857142857142857\cdots\]
%Do you pick up on the fact that $2*14=28$ and $2*28=56$ and $2*56=114$, and that when you carry the one you get $57$ instead? And don't worry, the 1 won't haunt us, probably just because Hindi-Arabic numbers dealt with it in stride. Anyway, ``14 28 57 14 28 57...'' is a pattern, right? Indeed, each pattern has a certain shape or repetitiveness, like the tree we saw last chapter in \cref{ex.cofree_dyn_sys}:
%\[
%\treepic
%\]
%Do you pick up on the fact that every tree sitting at a green dot is the same as every other one, and same with yellow and red? That's a pattern, right?
%
%Indeed, when someone says ``there's a pattern in my life'', they're talking about something that recurs, something with a certain kind of \emph{shape}, something with a rhyme to it. If they pick up on something again and again, it's a pattern. That's rhyme's reason.
%
%Isn't it true that in some sense a pattern is dynamic, that it's not a still-life, but more like a movie? And in some sense don't we move \emph{with} this pattern, either caught up in it like a nightmare replaying endlessly or skillfully manifesting it like a star basketball player making another beautiful point? Good or bad, to our benefit or loss, we notice and pick up on the pattern, and we carry its load. Maybe we could say that it's like the pattern is a molecule and some part of us is like a receptor for this kind of molecule.
%
%Our lives are patterned, and so are the lives of our machines and computer programs. Day in and day out, our billions of receptors pick up on patterns in what we call reality, catching on to existing possibilities there. Day in and day out, our cars and boats and web browsers latch onto patterns and make them available to thought; thought plays the role of a pilot sitting in the cockpit.
%
%Somehow there is coherence between the patterns we pick up on and the way we operate on them with our thoughts. Otherwise, what good would thinking be? Can we not agree there is some coherence between what we call thought and what we call reality? We pick up patterns and we operate on them. We are like a sort of ``module'' bridging two realms, one called reality and one called mind. 
%
%\begin{figure}
%\centergraphics{graphics/lawvere.png}
%\caption{A picture by Bill Lawvere of something he was talking about once, that's related but a bit obscure. Anyway, neat-looking huh? It looks a little like our story, kinda lensy, dynamic systemsy, relating outside and inside. \spiz{Jaz, feel free to replace this paragraph with anything you want.}}
%\end{figure}
%
%A distilled version of the story so far---up to the end of the last paragraph---can be formalized mathematically, and we do so in this chapter. That is, we'll discuss the sense in which \emph{bimodules} $m$ (playing the role of ``us'' in the above story) sit between two toposes (``realms''). From one realm (playing the role of ``reality''), the bimodule $m$ ``picks up'' patterns. The other realm (playing the role of ``mind'') operates and moves through these patterns. Though the mind realm need not be any smaller than the reality realm, the two sides of this story are not symmetric in terms of how they interact with $m$.
%
%We saw in \cref{chapter.5} that the comonoids $\com{C}$ in the monoidal category $(\poly,\yon,\circ)$ can be identified with categories $\cat{C}$.  The cofree comonoid $\cofree{p}$ of $p$-trees for arbitrary polynomial $p$ were seen to be particularly interesting from a dynamics point of view, lending themselves to much of the language of ``patterns'' used in the story above. 
%
%The story of this chapter really gets started when we realize that copresheaves $\Phi\colon\cat{C}_p\to\smset$ on these cofree categories can be identified with dependent dynamical systems in the sense of \cref{def.gen_moore}. But more generally, copresheaves on any category have a number of pleasant characterizations in terms of comonoids in $\poly$. 
%
%Moreover, the bimodules $\cofree{q}\tickar[m]\cofree{p}$ between comonoids $\cofree{q}$ and $\cofree{p}$ correspond to parametric right adjoints $\cofree{p}\set\to\cofree{q}\set$ between the associated copresheaf categories, allowing us to migrate a dynamical system $\Phi$ of type $p$ to one of type $q$. One can describe this migration, this parametric right adjoint, in terms of receptors---or what database theorists call ``frozen instances''---picking up patterns in $\Phi$ and then sorting them into copresheaves on the target category $\cofree{q}$.
%
%Our goal in this chapter is to say the above carefully and with plenty of examples.
%



%\begin{definition}[Database schema and instance]
%Let $\cat{C}$ be a category. An \emph{attribute structure} on $\cat{C}$ is a pair $(V, \alpha)$ where
%\begin{enumerate}
%	\item $V$ is a set, elements of which are called \emph{attribute values} and
%	\item $\alpha\colon V\to \Ob(\cat{C})$ is a function, called the \emph{attribute assignment}.
%\end{enumerate}
%If $(V,\alpha)$ is an attribute structure on $\cat{C}$, we call the triple $(\cat{C},V,\alpha)$ a \emph{database schema} and refer to $\cat{C}$ as the \emph{entity category} of the schema.
%
%An \emph{instance} on $(\cat{C},V,\alpha)$ consists of a functor $I\colon\cat{C}\to\smset$ together with a function $v_c\colon I(c)\to\alpha\inv(c)$ for each $c\in\Ob(\cat{C})$.
%\end{definition}
%
%\begin{proposition}
%Let $\cat{C}$ be a category and $\eta_\cat{C}\colon\cat{C}\to\Ob(\cat{C})$ the unit cofunctor. An attribute structure on $\cat{C}$ can be identified with a $(\Ob(\cat{C}),0)$-bimodule $\Ob(\cat{C})\bimodfrom[V]0$. An instance on $(\cat{C},V,\alpha)$ can be identified with a square of the form
%\[
%\begin{tikzcd}[background color=theoremcolor]
%	\cat{C}\ar[r, bimr-biml, "I"]\ar[d, "\cofun" marking, "\eta"']&
%	0\ar[d, equal]\\
%	\Ob(\cat{C})\ar[r, bimr-biml, "V"']&
%	0\ar[ul, phantom, "\hphantom{\scriptstyle\alpha}\Downarrow\scriptstyle\alpha"]
%\end{tikzcd}
%\]
%\end{proposition}
%
